#include <assert.h>

#include "time_class.h"

#include "vector_s.h"

//great, a "sortable" vector

namespace libpetey {

  template <class type>
  vector_s<type>::vector_s(int n) {
    nel=n;
    array_size=n;
    data=new type[nel];
    missing=0.;
  }

  template <class type>
  vector_s<type>::vector_s(int n, type m) {
    nel=n;
    array_size=n;
    data=new type[nel];
    missing=m;
  }

  template <class type>
  vector_s<type>::vector_s(type *dt, int n, int ncp_flag) {
    nel=n;
    array_size=n;
    if (ncp_flag) {
      data=dt;
    } else {
      data=new type[nel];
      for (int i=0; i<n; i++) {
        data[i]=dt[i];
      }
    }
  }

  template <class type>
  vector_s<type>::~vector_s() {
    delete [] data;
  }

  template <class type>
  vector_s<type>::vector_s(vector_s<type> &other) {
    delete [] data;
    data=new type[other.nel];
    nel=other.nel;
    array_size=nel;
    missing=other.missing;
    for (int i=0; i<nel; i++) data[i]=other.data[i];
  }
    
  template <class type>
  vector_s<type> & vector_s<type>::operator = (vector_s<type> &other) {
    delete [] data;
    data=new type[other.nel];
    nel=other.nel;
    array_size=nel;
    missing=other.missing;
    for (int i=0; i<nel; i++) data[i]=other.data[i];
    return *this;		//can this work??
  }
    
  template <class type>
  type & vector_s<type>::operator [] (int ind) {
    assert(ind>-1);
    if (ind>=nel) {
      if (ind>=array_size) {
        type *newdata;
        array_size=(ind/array_size+1)*array_size;
        newdata=new type[array_size];
        for (int i=0; i<nel; i++) newdata[i]=data[i];
        for (int i=nel; i<=ind; i++) newdata[i]=missing;
        delete [] data;
        data=newdata;
      }
      nel=ind+1;
    }
    return data[ind];
  }

  template <class type>
  vector_s<type> & vector_s<type>::operator + (vector_s<type> &other) {
    vector_s<type> *result;
    assert(nel==other.nel);
    result=new vector_s<type>(nel, missing);
    for (int i=0; i<nel; i++) result->data[i]=data[i]+other.data[i];
    return *result;		//can this work??
  }
    
  template <class type>
  vector_s<type> & vector_s<type>::operator - (vector_s<type> &other) {
    vector_s<type> *result;
    assert(nel==other.nel);
    result=new vector_s<type>(nel, missing);
    for (int i=0; i<nel; i++) result->data[i]=data[i]-other.data[i];
    return *result;		//can this work??
  }
    
  template <class type>
  vector_s<type> & vector_s<type>::operator + (type &c) {
    vector_s<type> *result;
    result=new vector_s<type>(nel, missing);
    for (int i=0; i<nel; i++) result->data[i]=data[i]+c;
    return *result;		//can this work??
  }
    
  template <class type>
  vector_s<type> & vector_s<type>::operator - (const type &c) {
    vector_s<type> *result;
    result=new vector_s<type>(nel, missing);
    for (int i=0; i<nel; i++) result->data[i]=data[i]-c;
    return *result;		//can this work??
  }

  template <class type>
  vector_s<type> & vector_s<type>::operator * (const double &c) {
    vector_s<type> *result;
    result=new vector_s<type>(nel, missing);
    for (int i=0; i<nel; i++) result->data[i]=data[i]*c;
    return *result;		//can this work??
  }
    
  template <class type>
  vector_s<type> & vector_s<type>::operator / (const double &c) {
    vector_s<type> *result;
    result=new vector_s<type>(nel, missing);
    for (int i=0; i<nel; i++) result->data[i]=data[i]/c;
    return *result;		//can this work??
  }

  template <class type>
  int vector_s<type>::operator == (vector_s<type> &other) {
    assert(nel == other.nel);
    for (int i=0; i<nel; i++) {
      if (other.data[i] != data[i]) return 0;
    }
    return 1;
  }

  template <class type>
  int vector_s<type>::operator > (vector_s<type> &other) {
    assert(nel == other.nel);
    for (int i=0; i<nel; i++) {
      if (data[i] > other.data[i]) return 1;
		else if (data[i] < other.data[i]) return 0;
    }
    return 0;
  }

  template <class type>
  int vector_s<type>::operator < (vector_s<type> &other) {
    assert(nel == other.nel);
    for (int i=0; i<nel; i++) {
      if (data[i] < other.data[i]) return 1;
		else if (data[i] > other.data[i]) return 0;
    }
    return 0;
  }

  template <class type>
  int vector_s<type>::operator >= (vector_s<type> &other) {
    assert(nel == other.nel);
    for (int i=0; i<nel; i++) {
      if (data[i] > other.data[i]) return 1;
		else if (data[i] < other.data[i]) return 0;
    }
    return 1;
  }

  template <class type>
  int vector_s<type>::operator <= (vector_s<type> &other) {
    assert(nel == other.nel);
    for (int i=0; i<nel; i++) {
      if (data[i] < other.data[i]) return 1;
		else if (data[i] > other.data[i]) return 0;
    }
    return 1;
  }

  template <class type>
  int vector_s<type>::size () {
    return nel;
  }

  template <class type>
  vector_s<type>::operator type * () {
    return data;
  }

  template class vector_s<int32_t>;
  template class vector_s<int64_t>;
  template class vector_s<float>;
  template class vector_s<double>;
  template class vector_s<time_class>;
 
} //end fucking namespace libwhathisface...
