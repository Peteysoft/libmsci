#ifndef SC_TYPE__H 
#define SC_TYPE__H

#include "sparse_array.h"

using namespace libpetey;
using namespace libsparse;

typedef double scalar_t;
typedef int32_t integer;

typedef sparse<integer, scalar_t> sparse_t;
typedef full_matrix<integer, scalar_t> full_t;
typedef sparse_array<integer, scalar_t> sparse_array_t; 

class sc_t {
  public:
    virtual ~sc_t()=0;
    int tflag;			//is it a temporary?
};

class sc_str_t: public sc_t {
  public:
    sc_str_t(char *str, int tf=0);
    virtual ~sc_str_t();
    char *s;

};

class sc_scal_t: public sc_t {
  public:
    sc_scal_t(scalar_t val, int tf=0);
    virtual ~sc_scal_t();
    scalar_t value;
};

class sc_vec_t: public sc_t {
  public:
    sc_vec_t(int tf=1);
    sc_vec_t(char *filename, int tf=1);
    virtual ~sc_vec_t();
    scalar_t *data;
    int n;
};

class sc_mat_t: public sc_t {
  public:
    sc_mat_t(int tf=1);
    sc_mat_t(char *filename, int t, int tf=1);
    virtual ~sc_mat_t();
    matrix_base<integer, scalar_t> *mat;
};

class sc_lval_t {
  protected:
    char *name;
    sc_t *var;
    scalar_t **view;
    int n;
  public:
    sc_lval_t(char *nm, sc_t *sub);
    sc_lval_t(sc_mat_t *v, sc_t *s1, sc_t *s2);
    ~sc_lval_t();

    int assign(sc_t *v);
};

//basic arithmetic operators:
sc_t * sc_add(sc_t *v1, sc_t *v2);
sc_t * sc_minus(sc_t *v1, sc_t *v2);
int sc_minus(sc_t *v);
sc_t * sc_mult(sc_t *v1, sc_t *v2);
sc_t * sc_mod(sc_t *v1, sc_t *v2);
sc_t * sc_sub(sc_t *v1, sc_t *v2);
sc_t * sc_sub(sc_t *v1, sc_t *v2, sc_t *v3);
sc_t * sc_range(sc_t *v1, sc_t *v2);
sc_t * sc_cprod(sc_t *v1, sc_t *v2);
sc_t * sc_quot(sc_t *v1, sc_t *v2);
sc_t * sc_pow(sc_t *v1, sc_t *v2);
sc_t * sc_norm(sc_t *v);

//variable type as integer code:
int sc_type_of(sc_t *v);

#endif

