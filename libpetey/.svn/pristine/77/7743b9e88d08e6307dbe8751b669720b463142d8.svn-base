#include <ctype.h>

#include "linked.h"
#include "grammar_t.h"

expr_t::expr_t() {}

expr_t::~expr_t() {}

primitive::primitive(char v1) {
  val=v1;
}

primitive::nver() {
  return 1;
}

compound::compound() {
  ntyp=0;
}

compound::compound(expr_t **neex, int n) {
  sub[0]=neex;
  nsub[0]=n;
  ntyp=1;
}

int compound::add(expr_t **neex, int n) {
  sub[ntyp]=neex;
  nsub[ntyp]=n;
  ntyp++;

  return ntyp;
}

int compound::nver() {
  return ntyp;
}

grammar_t::grammar_t() {
}

int grammar_t::add(char *name1, char *def) {
  linked_list<int> start;
  linked_list<int> end;
  char oldc;
  int *ind1=NULL;
  int *ind2=NULL;
  int n1, n2;
  char *name2;
  expr_t **neex=NULL;
  long id, id1;
  int i;
  int err=0;

  //do nothing but find all the starts and ends of words (space-separated character strings):
  oldc=def[0];
  if (isalpha(oldc)) start.add(0);
  for (i=1; def[i]!='\0'; i++) {
    if (isblank(oldc) && isblank(def[i])!=1) {
      start.add(i);
    }
    if (isblank(def[i]) && isblank(oldc)!=1) {
      end.add(i);
    }
  }
  if (isblank(expr[i-1]!=1) end.add(i-1);

  ind1=start.make_array(n1);
  ind2=start.make_array(n2);

  assert(n1==n2);

  neex=new expr_t *[n1];

  for (i=0; i<n1; i++) {
    name2=def+ind1[i];
    name2[ind2[i]]='\0';
    if (name2[0]==''') {
      if (name2[1]=='\0') {
        fprintf(stderr, "grammar_t: syntax error, subexpr. %d\n", i);
        fprintf(stderr, "        --single quote must be followed by primitive\n");
        err=-1;
        goto finish;
      }
      if (name2[2]!='\0' || name2[2]!=''') {
        fprintf(stderr, "grammar_t: syntax error, subexpr. %d\n", i);
        fprintf(stderr, "        --primitives must be enclose by single quotes or a quote and a space\n");
        err=-1;
        goto finish;
      }
      id=name.lookup(name2[1]);
      if (id<0) {
        id=name.add(name2[1]);
        exprlist[id]=new primitive(name2[1]);
      }
    } else if (isalpha(name2[0])!=1) {
      fprintf(stderr, "grammar_t: syntax error, subexpr. %d\n", i);
      fprintf(stderr, "        --expression names must begin with a letter\n");
      err=-1;
      goto finish;
    } else {
      for (int j=ind1[i]+1; j<ind2[i]; j++) {
        if (isalnum(def[j])!=1 || def[j]!='_') {
          fprintf(stderr, "grammar_t: syntax error, subexpr. %d\n", i);
          fprintf(stderr, "        --expression names must be composed of letters, number or underscores\n");
          err=-1;
          goto finish;
        }
      }
      id=name.lookup(name2);
      if (id<0) {
        fprintf(stderr, "grammar_t: symbol, %s, is undefined\n", name2);
        err=-2;
        goto finish;
      }
      id=name.add(name2);
    }
    neex[i]=exprlist[id];
  }

  id=name.lookup(name1);
  if (id<0) {
    name.add(name1);
    exprlist[id]=new compound();
  }
  exprlist[id]->add(neex, n1);

  finish:
    if (ind1!=NULL) delete [] ind1;
    if (ind2!=NULL) delete [] ind2;

  return err;
} 

