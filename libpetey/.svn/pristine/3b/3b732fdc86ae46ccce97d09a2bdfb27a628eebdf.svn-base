#include "sparse_array.h"
#include "vector_s.cc"

typedef double scalar_t;
typedef int32_t integer;

//there is only one symbol table:
symbol_table symtab;
vector_s<int> vartyp;

class sc_t {
  virtual ~sc_t()=0;
};

class sc_str_t: public sc_t {
  public:
    sc_str_t(char *str);
    virtual ~sc_str_t();
    char *s;

};

class sc_scal_t: public sc_t {
  public:
    sc_scal_t(scalar_t val);
    virtual ~sc_scal_t();
    real value;
};

class sc_vec_t: public sc_t {
  public:
    sc_vec_t();
    sc_vec_t(char *filename);
    virtual ~sc_vec_t();
    vector_s<scalar_t> *data;
};

class sc_mat_t: public sc_t {
  public:
    sc_mat_t();
    sc_mat_t(char *filename, int t);
    virtual ~sc_mat_t();
    matrix_base<scalar_t, integer> *mat;
};

typedef vector_s<sc_t *> sc_list_t;

class sc_lval_t {
  protected:
    char *name;
    sc_t *var;
    scalar_t **view;
    int n;
  public:
    sc_lval_t(char *nm, sc_t *sub);
    sc_lval_t(sc_mat_t *v, sc_t *s1, sc_t *s2);
    ~sc_lval_t();

    int assign(sc_t *v);
}

//basic arithmetic operators:
sc_t * sc_add(sc_t *v1, sc_t *v2);
sc_t * sc_minus(sc_t *v1, sc_t *v2);
int sc_minus(sc_t *v);
sc_t * sc_mult(sc_t *v1, sc_t *v2);
sc_t * sc_mod(sc_t *v1, sc_t *v2);
sc_t * sc_sub(sc_t *v1, sc_t *v2);
sc_t * sc_sub(sc_t *v1, sc_t *v2, sc_t *v3);
sc_t * sc_range(sc_t *v1, sc_t *v2);
sc_t * sc_cprod(sc_t *v1, sc_t *v2);
sc_t * sc_quot(sc_t *v1, sc_t *v2);
sc_t * sc_pow(sc_t *v1, sc_t *v2);
sc_t * sc_norm(sc_t *v);

//variable type as integer code:
int sc_type(sc_t *v);

//assignment variable (write to file):
int sc_assign(char *name, sc_t *v);

//subroutine calls:
int call_command(long id, sc_list_t *arg);
sc_t * call_function(long id, sc_list_t *arg);

