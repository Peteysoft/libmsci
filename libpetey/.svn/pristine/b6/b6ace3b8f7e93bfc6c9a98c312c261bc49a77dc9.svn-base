#include <stdint.h>
#include <stdio.h>
#include <algorithm>

#include "kselect.h"

namespace libpetey {

  //lets have a showdown:
  template <class type>
  kselect_base<type>::kselect_base(long k1) {
    k=k1;
  }

  template <class type>
  kselect_base<type>::kselect_base() {}

  template <class type>
  kselect_base<type>::~kselect_base() {}

  template <class type>
  kselect_tree<type>::kselect_tree(long k1) {
    this->k=k1;
  }

  template <class type>
  kselect_tree<type>::~kselect_tree() {
  }

  template <class type>
  long kselect_tree<type>::add(type val) {
    long n;
    n=data.add(val);
    if (n>this->k) {
      n=data.delete_greatest();
    }
    return n;
  }

  template <class type>
  void kselect_tree<type>::get(type *kleast) {
    data.decompose(kleast, this->k);
  }

  template <class type>
  kselect_heap<type>::kselect_heap(long k1) {
    this->k=k1;
    data=new vector<type>(this->k);
  }

  template <class type>
  kselect_heap<type>::~kselect_heap() {
    delete data;
  }

  template <class type>
  long kselect_heap<type>::add(type val) {
    long n;
    data->push_back(val);
    n=data->size();
    if (n>this->k) {
      push_heap(data->begin(), data->end());
      pop_heap(data->begin(), data->end());
      n--;
    } else if (n==this->k) {
      make_heap(data->begin(), data->end());
    }
    return n;
  }

  template <class type>
  void kselect_heap<type>::get(type *kleast) {
    sort_heap(data->begin(), data->end());
    for (long i=0; i<this->k; i++) kleast[i]=(*data)[i];
  }

  template <class type>
  kselect_quick<type>::kselect_quick(long k1) {
    this->k=k1;
    data=new vector_s<type>(this->k);
    ncur=0;
  }

  template <class type>
  kselect_quick<type>::kselect_quick(long k1, long n) {
    this->k=k1;
    data=new vector_s<type>(n);
    ncur=0;
  }

  template <class type>
  kselect_quick<type>::~kselect_quick() {
    delete data;
  }

  template <class type>
  long kselect_quick<type>::add(type val) {
    (*data)[ncur]=val;
    ncur++;
    //printf("kselect_quick: adding value; current list:\n");
    //data->print(stdout);
    return ncur;
  }

  template <class type>
  void kselect_quick<type>::get(type *kleast) {
    type *d2;
    long n;
    d2=(type *) *data;
    n=data->size();
    kleast_quick(d2, n, this->k);
    for (long i=0; i<this->k; i++) kleast[i]=d2[i];
  }

  template <class type>
  kiselect_base<type>::kiselect_base(long k1) {
    k=k1;
  }

  template <class type>
  kiselect_base<type>::kiselect_base() {}

  template <class type>
  kiselect_base<type>::~kiselect_base() {}

  template <class type>
  kiselect_tree<type>::kiselect_tree(long k1) {
    this->k=k1;
    ncur=0;
  }

  template <class type>
  kiselect_tree<type>::~kiselect_tree() {
  }

  template <class type>
  long kiselect_tree<type>::add(type val) {
    long n;
    n=data.add(val, ncur);
    ncur++;
    if (n>this->k) {
      n=data.delete_greatest();
    }
    return n;
  }

  template <class type>
  long kiselect_tree<type>::add(type val, long ind) {
    long n;
    n=data.add(val, ind);
    ncur++;
    if (n>this->k) {
      n=data.delete_greatest();
    }
    return n;
  }

  template <class type>
  void kiselect_tree<type>::get(type *kleast, long *ind) {
    data.decompose(kleast, ind, this->k);
  }

  template <class type>
  int heap_ind_el_comp(const heap_ind_el<type> &v1, heap_ind_el<type> &v2) {
    if (v1.data<v2.data) return -1;
    if (v1.data>v2.data) return 1;
    return 0;
  }

  template <class type>
  kiselect_heap<type>::kiselect_heap(long k1) {
    this->k=k1;
    data=new vector<heap_ind_el<type> >(this->k);
  }

  template <class type>
  kiselect_heap<type>::~kiselect_heap() {
    delete data;
  }

  template <class type>
  long kiselect_heap<type>::add(type val) {
    long n;
    heap_ind_el<type> v1;
    v1.data=val;
    n=data->size();
    v1.ind=n;
    data->push_back(v1);
    n++;
    if (n>this->k) {
      push_heap(data->begin(), data->end(), &heap_ind_el_comp<type>);
      pop_heap(data->begin(), data->end(), &heap_ind_el_comp<type>);
      n--;
    } else if (n==this->k) {
      make_heap(data->begin(), data->end(), &heap_ind_el_comp<type>);
    }
    return n;
  }

  template <class type>
  long kiselect_heap<type>::add(type val, long ind) {
    long n;
    heap_ind_el<type> v1;
    v1.data=val;
    v1.ind=ind;
    data->push_back(v1);
    n=data->size();
    if (n>this->k) {
      push_heap(data->begin(), data->end(), &heap_ind_el_comp<type>);
      pop_heap(data->begin(), data->end(), &heap_ind_el_comp<type>);
      n--;
    } else if (n==this->k) {
      make_heap(data->begin(), data->end(), &heap_ind_el_comp<type>);
    }
    return n;
  }

  template <class type>
  void kiselect_heap<type>::get(type *kleast, long *ind) {
    sort_heap(data->begin(), data->end(), &heap_ind_el_comp<type>);
    for (long i=0; i<this->k; i++) {
      kleast[i]=(*data)[i].data;
      ind[i]=(*data)[i].ind;
    }
  }

  template <class type>
  kiselect_quick<type>::kiselect_quick(long k1) {
    this->k=k1;
    data=new vector_s<type>(this->k);
    ind=new vector_s<long>(this->k);
    ncur=0;
  }

  template <class type>
  kiselect_quick<type>::kiselect_quick(long k1, long n) {
    this->k=k1;
    data=new vector_s<type>(n);
    ind=new vector_s<long>(n);
    ncur=0;
  }

  template <class type>
  kiselect_quick<type>::~kiselect_quick() {
    delete data;
  }

  template <class type>
  long kiselect_quick<type>::add(type val) {
    long n;
    n=data->size();
    (*data)[n]=val;
    (*ind)[n]=n;
    return n+1;
  }

  template <class type>
  long kiselect_quick<type>::add(type val, long ind2) {
    (*data)[ncur]=val;
    (*ind)[ncur]=ind2;
    ncur++;
    return ncur;
  }

  template <class type>
  void kiselect_quick<type>::get(type *kleast, long *ind2) {
    long n;
    type *d2;
    long *ind1;
    n=data->size();
    d2=(type *) *data;
    ind1=(long *) *ind;
    n=data->size();
    kleast_quick(d2, n, this->k, ind1, 0, n-1);
    for (long i=0; i<this->k; i++) {
      kleast[i]=d2[i];
      ind2[i]=ind1[i];
    }
  }

  template class kselect_tree<float>;
  template class kselect_heap<float>;
  template class kselect_quick<float>;

  template class kselect_tree<double>;
  template class kselect_heap<double>;
  template class kselect_quick<double>;

  template class kiselect_tree<float>;
  template class kiselect_heap<float>;
  template class kiselect_quick<float>;

  template class kiselect_tree<double>;
  template class kiselect_heap<double>;
  template class kiselect_quick<double>;

} //end namespace libpetey
