%{
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <sys/stat.h>
#include <readline/history.h>

extern "C" {
  int yylex(void);
  int yyerror(const char *);
}

#include "parse_command_opts.h"
#include "sparse_calc_defs.h"
#include "error_codes.h"

#define YYDEBUG 1

using namespace sparse_calc;

%}

%union {
  sc_t * variable;
  sc_list_t *list;
  char *symbol;
  real scalar;
  long id;
  vector_s<long> *code;
}

%token ERROR
%token ENDFIRSTPASS
%token LEFT_BRAC RIGHT_BRAC LEFT_SUB RIGHT_SUB COMMA PLUS PROD CPROD 
		ASSIGN QUOTIENT MINUS DELIM NORMBRAC RANGE POW MOD
%token GT GE LT LE EQ NE

%token <variable> VARIABLE 
%token <variable> SYMBOL
%token <scalar> SCALAR
%token <id> MATRIX
%token <id> VECTOR
%token <id> SUBROUTINE

%left GT GE LT LE EQ NE
%left PLUS MINUS
%left PROD CPROD QUOTIENT MOD
%left LEFT_SUB RANGE
%right POW
%left LEFT_BRAC
%nonassoc UMINUS

%type <code> expression
%type <code> statement
%type <list> list

%%

statement_list: statement | statement_list statement;

statement: 
	| command
	| assignment 
	| DELIM
	| error DELIM {
		  yyclearin;
		  yyerrok;
		};

list: 
  expression {
      $$=new sc_list(20);
      $$->push($1);
    }
  | list COMMA expression {
      $1->push($3);
      $$=$1;
    };

command:
  COMMAND list DELIM {
      if (call_command($1, $2)!=0) YYERROR;
    };


expression: 
  SCALAR {
      $$=new sc_scal_t($1);
    }
  | VECTOR {
      $$=new sc_vec_t(symtab.get($1));
      if ($$==NULL) YYERROR;
    }
  | MATRIX {
      $$=new sc_mat_t(symtab.get($1), vartyp[$1]);
      if ($$==NULL) YYERROR;
    }
  | LEFT_BRAC expression RIGHT_BRAC {$$=$2;}
  | MINUS expression %prec UMINUS {
      if (sc_minus($2)!=0) YYERROR;
    }
  | expression PROD expression {
      $$=sc_prod($1, $3);
      delete $1;
      delete $3;
      if ($$==NULL) YYERROR;
    }
  | expression PLUS expression {
      $$=sc_add($1, $3);
      delete $1;
      delete $3;
      if ($$==NULL) YYERROR;
    }
  | expression MOD expression {
      $$=sc_mod($1, $3);
      delete $1;
      delete $3;
      if ($$==NULL) YYERROR;
    }
  | expression MINUS expression {
      int err=sc_minus($3);
      if (err!=0) {
        delete $1;
        delete $3;
        YYERROR;
      }
      $$=sc_plus($1, $3);
      delete $1;
      delete $3;
      if ($$==NULL) YYERROR;
    }
  | expression LEFT_SUB expression RIGHT_SUB {
      $$=sc_sub($1, $3);
      delete $1;
      delete $3;
      if ($$==NULL) YYERROR;
    }
  | expression LEFT_SUB expression COMMA expression RIGHT_SUB {
      $$=sc_sub($1, $3);
      delete $1;
      delete $3;
      if ($$==NULL) YYERROR;
    }
  | FUNCTION LEFT_BRAC list RIGHT_BRAC {
      $$=call_function($1, $3);
      if ($$==NULL) YYERROR;
    }
  | expression RANGE expression {
      $$=sc_range($1, $3);
      delete $1;
      delete $3;
      if ($$==NULL) YYERROR;
    }
  | expression CPROD expression {
      $$=sc_prod($1, $3);
      delete $1;
      delete $3;
      if ($$==NULL) YYERROR;
    }
  | expression QUOTIENT expression {
      $$=sc_quot($1, $3);
      delete $1;
      delete $3;
      if ($$==NULL) YYERROR;
    }
  | NORMBRAC expression NORMBRAC {
      $$=sc_norm($2);
      delete $2;
      if ($$==NULL) YYERROR;
    }
  | expression POW expression {
      $$=sc_pow($1, $3);
      delete $1;
      delete $2;
      if ($$==NULL) YYERROR;
    };

lvalue:
  SYMBOL LEFT_SUB expression RIGHT_SUB {
      $$=new lval_init($1, $3);
      delete [] $1;
      delete $3;
      if ($$==NULL) YYERROR;
    }
  | SYMBOL LEFT_SUB expression COMMA expression RIGHT_SUB {
      $$=new lval_init($1, $3, $5);
      delete [] $1;
      delete $3;
      delete $5;
      if ($$==NULL) YYERROR;
    };


assignment:
  lvalue ASSIGN expression {
      int err=$1->assign($3);
      delete $3;
      if (err!=0) YYERROR;
    }
  | SYMBOL ASSIGN expression {

    };


%%

#include <sys/timeb.h>
#include <sys/types.h>
#include <unistd.h>
#include <getopt.h>

int main (int argc, char **argv) {
  FILE *fs;
  string_petey dum;
  char *line;
  char c;
  long id;

  int hflag;
  int flag[20];
  void *opt_arg[20];
  int loc;

  int32_t maxniter=DEF_MAXNITER;
  int32_t nev=DEF_NEV;
  int32_t ncv=DEF_NARNOLDI;
  float tol=DEF_TOL;

  timeb date;
  pid_t pid;

  opt_arg[3]=&nev;
  opt_arg[4]=&ncv;
  opt_arg[5]=&tol;
  opt_arg[6]=&maxniter;

  argc=parse_command_opts(argc, argv, "dhpAvtILe", "%%%s%d%d%d%f%s%s", opt_arg, flag, 1);

  if (argc<0) {
    fprintf(stderr, "sparse_calc: Error parsing command line.\n");
    argc=-argc;
  }

  scalar_assign("MAXNITER", maxniter);
  scalar_assign("NEV", nev);
  scalar_assign("NARNOLDI", ncv);
  scalar_assign("TOL", tol);

  //user can make variable declarations at the command line:
  //(repeat options are not useful with parse_command_opts...)
  while ((c = getopt(argc, argv, "S:M:a:V")) != -1) {
    switch (c) {
      case ('S'):
        id=symtab.add(optarg);
        vartyp[id]=SPARSE_T;
        delflag.off(id);
        break;
      case ('M'):
        id=symtab.add(optarg);
        vartyp[id]=FULL_T;
        delflag.off(id);
        break;
      case ('a'):
        id=symtab.add(optarg);
        vartyp[id]=SPARSE_ARRAY_T;
        delflag.off(id);
        break;
      case ('V'):
        id=symtab.add(optarg);
        vartyp[id]=VEC_T;
        delflag.off(id);
        break;
      case ('?'):
        fprintf(stderr, "sparse_calc: Unknown option -%c -- ignored\n", optopt);
        break;
      default:
        fprintf(stderr, "sparse_calc: Error parsing command line.\n");
        break;
    }
        
  }

  argc-=optind;
  argv+=optind;

  //symtab.print();

  yydebug=flag[0];

  if (flag[2]) {
    path=(char *) opt_arg[2];
    loc=strlen(path);
    if (path[loc-1]!='/') {
      path=new char[loc+2];
      sprintf(path, "%s/", (char *) opt_arg[2]);
      delete [] (char *) opt_arg[2];
    }
  } else {
    path=new char[3];
    strcpy(path, "./");
  }

  if (flag[1]) {
    main_help_screen();
    return 0;
  }

  if (flag[7]) {
    read_history((char *) opt_arg[7]);
  }
  if (flag[8]) {
    if (run_script((char *) opt_arg[8])!=0) {
      fprintf(stderr, "sparse_calc: error running script, %s\n", (char *) opt_arg[8]);
      fprintf(stderr, "   ...starting interactive mode.\n");
    }
  }

  ftime(&date);
  pid=getpid();

  scalc_session_id=pid+date.time*100000;	//how big do PID's get??

  if (argc>0) {
    if (run_script(argv[0])!=0) {
      fprintf(stderr, "sparse_calc: error running script, %s\n", argv[0]);
      exit(UNABLE_TO_OPEN_FILE_FOR_READING);
    }
    if (flag[9]) {
      sc_makeflag=1;
    }
    sc_scriptflag=1;
  }

  yyparse();

  //clean up:
  printf("Deleting unsaved variables:\n");
  for (long i=0; i<symtab.entries(); i++) {
    char *symbol;
    char *command;
    if (vartyp[i]!=SCALAR_DATA) {
      if (delflag[i]) {
        symbol=symtab.get(i);
        command=new char[strlen(symbol)+10];
        //delete variables that haven't been saved
        //(doesn't help you if the process dies or is killed in the middle of a session...)
        sprintf(command, "rm %s", symbol);
        printf("%s\n", command);
        system(command);
        delete [] symbol;
        delete [] command;
      }
    }
  }

}

