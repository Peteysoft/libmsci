#include <algorithm>

//lets have a showdown:
template <class type>
kselect_base<type>::kselect_base(long k1) {
  k=k1;
}

template <class type>
kselect_heap<type>::kselect_tree(long k1) {
  k=k1;
}

template <class type>
kselect_tree<type>::~kselect_tree() {
}

template <type>
long kselect_tree<type>::add(type val) {
  long n;
  n=data.add(val);
  if (n>k) {
    n=data.delete_greatest();
  }
  return n;
}

template <type>
void kselect_tree<type>::get(type *kleast) {
  data.decompose(kleast, k);
}

template <class type>
kselect_heap<type>::kselect_heap(long k1) {
  k=k1;
  data=new vector<type>(k);
}

template <class type>
kselect_heap<type>::~kselect_heap() {
  delete data;
}

template <type>
long kselect_heap<type>::add(type val) {
  long n;
  data->push_back(val);
  n=data->size();
  if (n>k) {
    push_heap(data->begin(), data->end());
    pop_heap(data->begin(), data->end());
    n--;
  } else if (n==k) {
    make_heap(data->begin(), data->end());
  }
  return n;
}

template <type>
void kselect_heap<type>::get(type *kleast) {
  sort_heap(data->begin(), data->end());
  for (long i=0; i<k; i++) kleast[i]=data[i];
}

template <class type>
kselect_quick<type>::kselect_quick(long k1) {
  k=k1;
  data=new vector_s<type>(k);
}

template <class type>
kselect_quick<type>::kselect_quick(long k1, long n) {
  k=k1;
  data=new vector_s<type>(n);
}

template <class type>
kselect_quick<type>::~kselect_quick() {
  delete data;
}

template <type>
long kselect_quick<type>::add(type val) {
  long n;
  n=data->size();
  data->[n]=val;
  return n+1;
}

template <type>
void kselect_quick<type>::get(type *kleast) {
  type *d2;
  d2=(type *) data;
  kleast_quick(d2, data->size(), k);
  for (long i=0; i<k; i++) kleast[i]=d2[i];
}

template <class type>
kiselect_base<type>::kiselect_base(long k1) {
  k=k1;
}

template <class type>
kiselect_heap<type>::kiselect_tree(long k1) {
  k=k1;
}

template <class type>
kiselect_tree<type>::~kiselect_tree() {
}

template <type>
long kiselect_tree<type>::add(type val) {
  long n;
  n=data.nel();
  n=data.add(val, n);
  if (n>k) {
    n=data.delete_greatest();
  }
  return n;
}

template <type>
long kiselect_tree<type>::add(type val, long ind) {
  long n;
  n=data.add(val, ind);
  if (n>k) {
    n=data.delete_greatest();
  }
  return n;
}

template <type>
void kiselect_tree<type>::get(type *kleast, long *ind) {
  data.decompose(kleast, ind, k);
}


template <type>
struct heap_ind_el {
  type data;
  long ind;
}

int heap_ind_el_comp(const heap_ind_el &v1, heap_ind_el &v2) {
  if (v1.data<v2.data) return -1;
  if (v1.data>v2.data) return 1;
  return 0;
}

template <class type>
kiselect_heap<type>::kiselect_heap(long k1) {
  k=k1;
  data=new vector<heap_ind_el<type> >(k);
}

template <class type>
kiselect_heap<type>::~kiselect_heap() {
  delete data;
}

template <type>
long kiselect_heap<type>::add(type val) {
  long n;
  heap_ind_obj v1;
  v1.data=val;
  n=data->size();
  v1.ind=n;
  data->push_back(v1);
  n++;
  if (n>k) {
    push_heap(data->begin(), data->end(), &heap_ind_el_comp);
    pop_heap(data->begin(), data->end() &heap_ind_el_comp);
    n--;
  } else if (n==k) {
    make_heap(data->begin(), data->end(), &heap_ind_el_comp);
  }
  return n;
}

template <type>
long kiselect_heap<type>::add(type val, long ind) {
  long n;
  heap_ind_obj v1;
  v1.data=val;
  v1.ind=ind;
  data->push_back(v1);
  n=data->size();
  if (n>k) {
    push_heap(data->begin(), data->end(), &heap_ind_el_comp);
    pop_heap(data->begin(), data->end(), &heap_ind_el_comp);
    n--;
  } else if (n==k) {
    make_heap(data->begin(), data->end(), &heap_ind_el_comp);
  }
  return n;
}

template <type>
void kiselect_heap<type>::get(type *kleast, long *ind) {
  sort_heap(data->begin(), data->end(), &heap_ind_el_comp);
  for (long i=0; i<k; i++) {
    kleast[i]=data->[i].data;
    ind[i]=data->[i].ind;
  }
}

template <class type>
kiselect_quick<type>::kiselect_quick(long k1) {
  k=k1;
  data=new vector_s<type>(k);
  ind=new vector_s<long>(k);
}

template <class type>
kiselect_quick<type>::kiselect_quick(long k1, long n) {
  k=k1;
  data=new vector_s<type>(n);
  ind=new vector_s<long>(n);
}

template <class type>
kiselect_quick<type>::~kiselect_quick() {
  delete data;
}

template <type>
long kiselect_quick<type>::add(type val) {
  long n;
  n=data->size();
  data->[n]=val;
  ind->[n]=n;
  return n+1;
}

template <type>
long kiselect_quick<type>::add(type val, long ind2) {
  long n;
  n=data->size();
  data->[n]=val;
  ind->[n]=ind2;
  return n+1;
}

template <type>
void kiselect_quick<type>::get(type *kleast) {
  long n;
  type *d2;
  long *ind1;
  n=data->size();
  d2=(type *) data;
  ind1=(long *) ind;
  n=data->size();
  kleast_quick(d2, n, k, ind1, 0, n-1);
  for (long i=0; i<k; i++) {
    kleast[i]=d2[i];
    ind2[i]=ind1[i];
  }
}

