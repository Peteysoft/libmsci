#include "sc_glob.h"
#include "sc_op.h"

sc_t *sc_prod(int narg, sc_t **v) {
  sc_t *result=NULL;
  int t1, t2;		//types of each argument
  int d1f=1, d2f=1;	//delete argument at end?

  if (narg != 2) return NULL;

  t1=sc_type_of(v[0]);
  t2=sc_type_of(v[1]);

  //both scalars:
  if (t1==SC_SCALAR_T && t2==SC_SCALAR_T) {
    sc_scal_t *v1=(sc_scal_t *) v[0];
    sc_scal_t *v2=(sc_scal_t *) v[1];
    result=new sc_scal_t(v1->value*v2->value, 1);

  //one scalar, one vector:
  } else if ((t1==SC_SCALAR_T && t2==SC_VECTOR_T) || (t2==SC_SCALAR_T && t1==SC_VECTOR_T)) {
    sc_scal_t *v1;
    sc_vec_t *v2;
    if ((t1==SC_SCALAR_T && t2==SC_VECTOR_T) {
      v1=(sc_scal_t *) v[0];
      v2=(sc_vec_t *) v[1];
    } else if (t2==SC_SCALAR_T && t1==SC_VECTOR_T) {
      v1=(sc_scal_t *) v[1];
      v2=(sc_vec_t *) v[0];
    }
    result=new sc_vec_t(1);
    result->data=new scalar_t[v2->n];
    result->n=v2->n;
    for (int i=0; i<result->n; i++) result->data[i]=v2->data[i]*v1->value;

  //both are vectors:
  } else if (t1==SC_VECTOR_T && t2==SC_VECTOR) {
    sc_vec_t *v1=(sc_scal_t *) v[0];
    sc_vec_t *v2=(sc_vec_t *) v[1];
    scalar_t val=0;
    if (v1->n != v2->n) {
      fprintf("Type mismatch: vector dimensions do not agree\n");
      return NULL;
    }
    for (int i=0; i<v1->n; i++) val+=v1->data[i]*v2->data[i];
    result=new sc_scal_t(val, 1);

  //scalar and matrix:
  } else if ((t1==SC_SCALAR_T &&
		(t2==SC_FULL_T || t2==SC_SPARSE_T || t2==SC_SPARSE_MATRIX_T)) ||
		((t1==SC_FULL_T || t1==SC_SPARSE_T || t1==SC_SPARSE_MATRIX_T) ||
		(t2==SC_SCALAR_T))) {
    sc_scal_t *v1;
    sc_mat_t *v2;
    if (t1==SC_SCALAR_T &&
		(t2==SC_FULL_T || t2==SC_SPARSE_T || t2==SC_SPARSE_MATRIX_T)) {
      v2=(sc_scal_t *) v[0];
      v1=(sc_mat_t *) v[1];
      d2f=0;
    } else if ((t1==SC_FULL_T || t1==SC_SPARSE_T || t1==SC_SPARSE_MATRIX_T) ||
		(t2==SC_SCALAR_T)) {
      v1=(sc_mat_t *) v[0];
      v2=(sc_scal_t *) v[1];
      d1f=0;
    }
    v1->mat->scal_mult(v2->value);
    result=v1;

  //vector and matrix:
  } else if (t1==SC_VECTOR_T &&
		(t2==SC_FULL_T || t2==SC_SPARSE_T || t2==SC_SPARSE_MATRIX_T)) {
    integer m, n;
    sc_vec_t *v1=(sc_vec_t *) v[0];
    sc_mat_t *v2=(sc_mat_t *) v[1];
    v2->mat->size(m, n);
    if (m!=v1->n) {
      fprintf(stderr, "Vector size and matrix inner dimension must match\n");
      return NULL;
    }
    result=new sc_vec_t(1);
    result->mat=v2->mat->left_vec_mult(v1->data);
    result->n=n;
  } else if ((t1==SC_FULL_T || t1==SC_SPARSE_T || t1==SC_SPARSE_MATRIX_T) ||
		(t2==SC_VECTOR_T)) {
    integer m, n;
    sc_mat_t *v1=(sc_mat_t *) v[0];
    sc_vec_t *v2=(sc_vec_t *) v[1];
    v2->size(m, n);
    if (n!=v1->n) {
      fprintf(stderr, "Matrix inner dimension and vector size must match\n");
      return NULL;
    }
    result=new sc_vec_t(1);
    result->data=v1->vec_mult(v2->data);
    result->n=m;

  //both are matrices:
  } else if ((t2==SC_FULL_T || t2==SC_SPARSE_T || t2==SC_SPARSE_MATRIX_T) &&
		((t1==SC_FULL_T || t1==SC_SPARSE_T || t1==SC_SPARSE_MATRIX_T)) {
    sc_mat_t *v1=(sc_mat_t *) v[0];
    sc_mat_t *v2=(sc_mat_t *) v[1];
    result=new sc_mat_t(1);
    result->mat=v1->mat_mult(v2->mat);
  } else {
    fprintf(stderr, "Type mismatch\n");
  }

  if (d1f && v[0]->tflag) delete v[0];
  if (d2f && v[1]->tflag) delete v[1];

  return result;
}

sc_t *sc_add(int narg, sc_t **v) {
  sc_t *result=NULL;
  int t1, t2;		//types of each argument

  if (narg != 2) return NULL;

  t1=sc_type_of(v[0]);
  t2=sc_type_of(v[1]);

  //both scalars:
  if (t1==SC_SCALAR_T && t2==SC_SCALAR_T) {
    sc_scal_t *v1=(sc_scal_t *) v[0];
    sc_scal_t *v2=(sc_scal_t *) v[1];
    result=new sc_scal_t(v1->value+v2->value, 1);

  //one scalar, one vector:
  } else if ((t1==SC_SCALAR_T && t2==SC_VECTOR_T) || (t2==SC_SCALAR_T && t1==SC_VECTOR_T)) {
    sc_scal_t *v1;
    sc_vec_t *v2;
    if ((t1==SC_SCALAR_T && t2==SC_VECTOR_T) {
      v1=(sc_scal_t *) v[0];
      v2=(sc_vec_t *) v[1];
    } else if (t2==SC_SCALAR_T && t1==SC_VECTOR_T) {
      v1=(sc_scal_t *) v[1];
      v2=(sc_vec_t *) v[0];
    }
    result=new sc_vec_t(1);
    result->data=new scalar_t[v2->n];
    result->n=v2->n;
    for (int i=0; i<result->n; i++) result->data[i]=v2->data[i]+v1->value;

  //both are vectors:
  } else if (t1==SC_VECTOR_T && t2==SC_VECTOR) {
    sc_vec_t *v1=(sc_scal_t *) v[0];
    sc_vec_t *v2=(sc_vec_t *) v[1];
    result=new sc_vec_t(1);
    if (v1->n != v2->n) {
      fprintf("Type mismatch: vector dimensions do not agree\n");
      return NULL;
    }
    result->n=v1->n;
    result->data=new scalar_t[result->n];
    for (int i=0; i<v1->n; i++) result->data[i]=v1->data[i]+v2->data[i];

  //scalar and matrix:
  } else if ((t1==SC_SCALAR_T &&
		(t2==SC_FULL_T || t2==SC_SPARSE_T || t2==SC_SPARSE_MATRIX_T)) ||
		((t1==SC_FULL_T || t1==SC_SPARSE_T || t1==SC_SPARSE_MATRIX_T) ||
		(t2==SC_SCALAR_T))) {
    sc_scal_t *v1;
    sc_mat_t *v2;
    full_t *const;
    integer m, n;
    if (t1==SC_SCALAR_T &&
		(t2==SC_FULL_T || t2==SC_SPARSE_T || t2==SC_SPARSE_MATRIX_T)) {
      v2=(sc_scal_t *) v[0];
      v1=(sc_mat_t *) v[1];
    } else if ((t1==SC_FULL_T || t1==SC_SPARSE_T || t1==SC_SPARSE_MATRIX_T) ||
		(t2==SC_SCALAR_T)) {
      v1=(sc_mat_t *) v[0];
      v2=(sc_scal_t *) v[1];
    }
    v1->size(m, n)
    const=new full_t(m, n);
    const->ones();
    const->scal_mult(v2->value);
    result=new sc_mat_t(1);
    result->mat=v1->mat->add(const);
    delete const;

  //vector and matrix:
  } else if ((t1==SC_VECTOR_T &&
		(t2==SC_FULL_T || t2==SC_SPARSE_T || t2==SC_SPARSE_MATRIX_T)) ||
		((t1==SC_FULL_T || t1==SC_SPARSE_T || t1==SC_SPARSE_MATRIX_T) ||
		(t2==SC_VECTOR_T))) {
    integer m, n, n1;
    sc_vec_t *v1;
    sc_mat_t *v2;
    sparse_t *diag;
    if (t1==SC_VECTOR_T &&
		(t2==SC_FULL_T || t2==SC_SPARSE_T || t2==SC_SPARSE_MATRIX_T)) {
      v2=(sc_vec_t *) v[0];
      v1=(sc_mat_t *) v[1];
    } else if ((t1==SC_FULL_T || t1==SC_SPARSE_T || t1==SC_SPARSE_MATRIX_T) ||
		(t2==SC_VECTOR_T)) {
      v1=(sc_mat_t *) v[0];
      v2=(sc_vec_t *) v[1];
    }
    v2->mat->size(m, n);
    if (m<n) n1=m; else n1=n;
    if (n1!=v1->n) {
      fprintf(stderr, "Matrix inner dimension and vector size must match\n");
      return NULL;
    }
    diag=new sparse_t(m, n);
    diag->identity();
    for (integer i=0; i<n1; i++) diag.cel(v2->data[i], i, i);
    result=new sc_vec_t(1);
    result->mat=v1->mat->add(diag);
    delete diag;

  //both are matrices:
  } else if ((t2==SC_FULL_T || t2==SC_SPARSE_T || t2==SC_SPARSE_MATRIX_T) &&
		((t1==SC_FULL_T || t1==SC_SPARSE_T || t1==SC_SPARSE_MATRIX_T)) {
    sc_mat_t *v1=(sc_mat_t *) v[0];
    sc_mat_t *v2=(sc_mat_t *) v[1];
    result=new sc_mat_t(1);
    result->mat=v1->add(v2->mat);
  } else {
    fprintf(stderr, "Type mismatch\n");
  }

  //currently, all variables in ram are temporaries:
  if (v[0]->tflag) delete v[0];
  if (v[1]->tflag) delete v[1];

  return result;
}

