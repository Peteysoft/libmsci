#include "sc_op.h"

sc_t *sc_prod(int narg, sc_t **v) {
  sc_t *result;
  int t1, t2;		//types of each argument
  if (narg!=2) return NULL;

  t1=sc_type_of(v[0]);
  t2=sc_type_of(v[1]);

  //both scalars:
  if (t1==SC_SCALAR_T && t1==SC_SCALAR_T) {
    sc_scal_t *v1=(sc_scal_t *) v[0];
    sc_scal_t *v2=(sc_scal_t *) v[1];
    result=new sc_scal_t(v1->value*v2->value, 1);
  //one scalar, one vector:
  } else if ((t1==SC_SCALAR_T && t2==SC_VECTOR_T) || (t2==SC_SCALAR_T && t1==SC_VECTOR_T) {
    sc_scal_t *v1;
    sc_vec_t *v2;
    if ((t1==SC_SCALAR_T && t2==SC_VECTOR_T) {
      v1=(sc_scal_t *) v[0];
      v2=(sc_vec_t *) v[1];
    } else if (t2==SC_SCALAR_T && t1==SC_VECTOR_T) {
      v1=(sc_scal_t *) v[1];
      v2=(sc_vec_t *) v[0];
    }
    result=new sc_vec_t(1);
    result->data=new scalar_t[v2->n];
    result->n=v2->n;
    for (int i=0; i<result->n; i++) result->data[i]=v2->data[i]*v1->value;
  //both are vectors:
  } else if (t1==SC_VECTOR_T && t2==SC_VECTOR) {
    sc_vec_t *v1=(sc_scal_t *) v[0];
    sc_vec_t *v2=(sc_vec_t *) v[1];
    scalar_t val=0;
    if (v1->n != v2->n) {
      fprintf("Type mismatch: vector dimensions do not agree\n");
      return NULL;
    }
    for (int i=0; i<v1->n; i++) val+=v1->data[i]*v2->data[i];
    result=new sc_scal_t(val, 1);
  //scalar and matrix:
  } else if ((t1==SC_SCALAR_T &&
		(t2==SC_FULL_T || t2==SC_SPARSE_T || t2==SC_SPARSE_MATRIX_T)) ||
		((t1==SC_FULL_T || t1==SC_SPARSE_T || t1==SC_SPARSE_MATRIX_T) ||
		(t2==SC_SCALAR_T))) {
    sc_scal_t *v1;
    sc_mat_t *v2;
    if (t1==SC_SCALAR_T &&
		(t2==SC_FULL_T || t2==SC_SPARSE_T || t2==SC_SPARSE_MATRIX_T)) {
      v1=(sc_scal_t *) v[0];
      v2=(sc_mat_t *) v[1];
    } else if ((t1==SC_FULL_T || t1==SC_SPARSE_T || t1==SC_SPARSE_MATRIX_T) ||
		(t2==SC_SCALAR_T)) {
      v1=(sc_scal_t *) v[1];
      v2=(sc_mat_t *) v[0];
    }
    v2->mat->scal_mult(v1->value);
    result=new sc_mat_t(1);
    //what a waste:
    result->mat=copy_matrix(v2);
  //vector and matrix:
  } else if (t1==SC_VECTOR_T &&
		(t2==SC_FULL_T || t2==SC_SPARSE_T || t2==SC_SPARSE_MATRIX_T)) {
    integer m, n;
    sc_vec_t *v1=(sc_vec_t *) v[0];
    sc_mat_t *v2=(sc_mat_t *) v[1];
    v2->size(m, n);
    if (m!=v1->n) {
      fprintf(stderr, "Vector size and matrix inner dimension must match\n");
      return NULL;
    }
    result=new sc_vec_t(1);
    result->mat=v2->left_vec_mult(v1->data, v1->n);
  } else if ((t1==SC_FULL_T || t1==SC_SPARSE_T || t1==SC_SPARSE_MATRIX_T) ||
		(t2==SC_VECTOR_T)) {
    integer m, n;
    sc_mat_t *v1=(sc_mat_t *) v[0];
    sc_vec_t *v2=(sc_vec_t *) v[1];
    v2->size(m, n);
    if (n!=v1->n) {
      fprintf(stderr, "Matrix inner dimension and vector size must match\n");
      return NULL;
    }
    result=new sc_vec_t(1);
    result->data=v1->vec_mult(v2->data, v2->n);
  //both are matrices:
  } else if ((t2==SC_FULL_T || t2==SC_SPARSE_T || t2==SC_SPARSE_MATRIX_T) &&
		((t1==SC_FULL_T || t1==SC_SPARSE_T || t1==SC_SPARSE_MATRIX_T)) {
    sc_mat_t *v1=(sc_mat_t *) v[0];
    sc_mat_t *v2=(sc_mat_t *) v[1];
    result=new sc_mat_t(1);
    result->mat=v1->mat_mult(v2->mat);
  }
  return result;
}

