#include <ctype.h>

#include "linked.h"
#include "grammar_t.h"

parse_tree::parse_tree(expr_t *e, int v, char *l, int n, parse_tree **s) {
  expr=e;
  ver=v;
  loc=l;
  sub=s;
}

parse_tree::~parse_tree() {
  for (int i=0; expr->ns[ver]; i++) {
    delete sub[i];
  }
  delete [] sub;
}

char *parse_tree::value() {
  char *result;
  result=new char[len];
  for (int i=0; i<len; i++) result[i]=loc[i];
  return result;
}

void parse_tree::print(int depth) {
  char *name;
  for (int i=0; i<depth; i++) printf("  ");
  if (sub==NULL) {
    printf("%c\n", loc[0]);
  } else {
    char *val=value();
    name=expr->nameof();
    printf("%s %s\n", name, value);
    delete [] name;
    delete [] value;
    for (int i=0; i<expr->ns(ver); i++) {
      sub[i]->print(depth+1);
    }
  }
}


expr_t::expr_t() {}

expr_t::~expr_t() {}

primitive::primitive(char v1) {
  val=v1;
}

int primitive::nver() {
  return 1;
}

int primitive::ns(int v) {
  return 0;
}

char * primitive::nameof() {
  result *char=new char[2];
  result[0]=''';
  result[1]=val;
  return result;
}

parse_tree *primitive::parse(char *string, int ver) {
  parse_tree *result=NULL;
  if (string[0]==val && ver==0) {
    result=new parse_tree(this, 0, string, 1, NULL);
  }
  return result;
}

compound::compound(grammar_t *g, long i) {
  grammar=g;
  ntyp=0;
  id=i;
}

int compound::add(expr_t **neex, int n) {
  sub[ntyp]=neex;
  nsub[ntyp]=n;
  ntyp++;

  return ntyp;
}

int compound::nver() {
  return ntyp;
}

int compound::ns(int v) {
  return nsub[v];
}

char * compound::nameof() {
  return grammar->get(id);
}

parse_tree * compound::parse(char *string, int ver) {
  parse_tree **sub_tree;
  int v1;
  int i;
  int len;
  char *lnew;

  sub_tree=new parse_tree*[nsub[ver]];
  for (int j=0; j<nsub[ver]; j++) sub_tree[j]=NULL;

  for (i=0; i<nsub[ver]; i++) {
    if (sub_tree[i]==NULL) {
      v1=0;
    } else {
      v1=sub_tree[i]->ver+1;
      delete sub_tree[i];
      sub_tree[i]=NULL;
    }
    for (int j=v1; j<sub[ver][i]->nver(); j++) {
      if (i>0) {
        lnew=sub_tree[i-1]->loc+sub_tree[i-1]->len;
      } else {
        lnew=loc;
      }
      sub_tree[i]=sub[ver][i]->parse(lnew, j);
      if (sub_tree[i]!=NULL) break;
    }
    if (sub_tree[i]==NULL) {
      i--;
      if (i<0) break;
    }
  }

  if (i<nsub[ver]) {
    delete [] sub_tree;
    return NULL;
  }

  len=0;
  for (int j=0; j<nsub[ver]; j++) len+=sub_tree[j]->len;

  return new parse_tree(this, ver, loc, len, sub_tree);
}

grammar_t::grammar_t() {
}

int grammar_t::add(char *name1, char *def) {
  linked_list<int> start;
  linked_list<int> end;
  char oldc;
  int *ind1=NULL;
  int *ind2=NULL;
  int n1, n2;
  char *name2;
  expr_t **neex=NULL;
  long id, id1;
  int i;
  int err=0;

  //do nothing but find all the starts and ends of words (space-separated character strings):
  oldc=def[0];
  if (isalpha(oldc)) start.add(0);
  for (i=1; def[i]!='\0'; i++) {
    if (isblank(oldc) && isblank(def[i])!=1) {
      start.add(i);
    }
    if (isblank(def[i]) && isblank(oldc)!=1) {
      end.add(i);
    }
  }
  if (isblank(expr[i-1]!=1) end.add(i-1);

  ind1=start.make_array(n1);
  ind2=start.make_array(n2);

  assert(n1==n2);

  neex=new expr_t *[n1];

  for (i=0; i<n1; i++) {
    name2=def+ind1[i];
    name2[ind2[i]]='\0';
    if (name2[0]==''') {
      if (name2[1]=='\0') {
        fprintf(stderr, "grammar_t: syntax error, subexpr. %d\n", i);
        fprintf(stderr, "        --single quote must be followed by primitive\n");
        err=-1;
        goto finish;
      }
      if (name2[2]!='\0' || name2[2]!=''') {
        fprintf(stderr, "grammar_t: syntax error, subexpr. %d\n", i);
        fprintf(stderr, "        --primitives must be enclosed by single quotes or a quote and a space\n");
        err=-1;
        goto finish;
      }
      if (name2[2]==''') name[2]='\0';
      id=name.lookup(name2);
      if (id<0) {
        id=name.add(name2);
        exprlist[id]=new primitive(name2[1]);
      }
    } else if (isalpha(name2[0])!=1) {
      fprintf(stderr, "grammar_t: syntax error, subexpr. %d\n", i);
      fprintf(stderr, "        --expression names must begin with a letter\n");
      err=-1;
      goto finish;
    } else {
      for (int j=ind1[i]+1; j<ind2[i]; j++) {
        if (isalnum(def[j])!=1 || def[j]!='_') {
          fprintf(stderr, "grammar_t: syntax error, subexpr. %d\n", i);
          fprintf(stderr, "        --expression names must be composed of letters, number or underscores\n");
          err=-1;
          goto finish;
        }
      }
      id=name.lookup(name2);
      if (id<0) {
        fprintf(stderr, "grammar_t: symbol, %s, is undefined\n", name2);
        err=-2;
        goto finish;
      }
      id=name.add(name2);
    }
    neex[i]=exprlist[id];
  }

  id=name.lookup(name1);
  if (id<0) {
    name.add(name1);
    exprlist[id]=new compound(this, id);
  }
  exprlist[id]->add(neex, n1);

  finish:
    if (ind1!=NULL) delete [] ind1;
    if (ind2!=NULL) delete [] ind2;

  return err;
} 

