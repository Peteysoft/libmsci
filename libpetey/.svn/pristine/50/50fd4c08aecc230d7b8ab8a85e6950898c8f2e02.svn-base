#include "vector_s.h"
#include "sparse_array.h"

namespace libpetey {
  namespace libsparse {

    //perform a vector multiplication:
    template <class index_t, class data_t, class vector_t>
    void sc_sparse_t<index_t, data_t, vector_t>::vect_mult2(vector_t &cand, vector_t &result) {
      for (index_t i=0; i<m; i++) result[i]=0;
      for (long i=0; i<nel; i++) {
        result[matrix[i].i]+=matrix[i].value*cand[matrix[i].j];
      }
    }

    //perform left vector multiplication:
    template <class index_t, class data_t, class vector_t>
    void sc_sparse_t<index_t, data_t, vector_t>::left_mult2(vector_t &cor, vector_t &result) {
      for (index_t i=0; i<m; i++) result[i]=0;
      for (long i=0; i<nel; i++) {
        result[matrix[i].j]+=matrix[i].value*cor[matrix[i].i];
      }
    }

    template <class index_t, class data_t, class vector_t>
    vector_t *sc_sparse_t<index_t, data_t, vector_t>::vect_mult2(vector_t *cand) {
      vector_t *result;
      result=new vector_t(m);
      vect_mult2(*cand, *result);
      return result;
    }

    template <class index_t, class data_t, class vector_t>
    vector_t * sc_sparse_t<index_t, data_t, vector_t>::left_mult2(vector_t *cor) {
      vector_t *result;
      result=new vector_t(n);
      left_mult2(*cor, *result);
      return result;
    }

    template <class index_t, class data_t, class vector_t>
    void sc_sparse_t<index_t, data_t, vector_t>::get_row2 (index_t i, vector_t &row) {
      sparse_el<index_t, data_t> search_blank(i, 0, 0);

      for (index_t j=0; j<n; j++) row[j]=0;
      if (nel == 0) return;
      update();
      last_search=bin_search(matrix, nel, search_blank, last_search);
      if (last_search >= nel) return;
      if (last_search==-1 || matrix[last_search].i<i) {
        last_search++;
      }

      for (index_t j=last_search; j<nel; j++) {
        if (matrix[j].i > i) break;
        row[matrix[j].j]=matrix[j].value;
      }
    }

    template <class index_t, class data_t, class vector_t>
    vector_t *sc_sparse_t<index_t, data_t, vector_t>::get_row2(index_t i) {
      vector_t *row;
      row=new vector_t(n);
      get_row(i, *row);
      return row;
    }



template <class index_t, class real, class vector_t, class sparse_t>
void sc_sparse_array_t<index_t, real, vector_t, sparse_t>::vect_mult2(vector_t &cand, vector_t &result) {
  vector_t *med, *s, *r;
  med=new vector_t(m);

  sparse_a[0]->vect_mult2(cand, result);
  r=&result;
  for (long i=1; i<nsparse; i++) {
    sparse_a[i]->vect_mult2(*r, *med);
    s=med;
    med=r;
    r=s;
  }
  //this check should probably be applied everywhere I use this trick
  //and result is not allocated inside the function...
  if (nsparse % 2 == 0) {
    for (index_t i=0; i<m; i++) result[i]=(*med)[i];
  }
  delete med;
}

template <class index_t, class real, class vector_t, class sparse_t>
vector_t * sc_sparse_array_t<index_t, real, vector_t, sparse_t>::vect_mult2(vector_t *cand) {
  vector_t *result;
  result=new vector_t(m);
  vect_mult2(*cand, *result);
  return result;
}

template <class index_t, class real, class vector_t, class sparse_t>
void sc_sparse_array_t<index_t, real, vector_t, sparse_t>::left_mult2(vector_t &cor, vector_t &result) {
  vector_t *med, *s, *r;
  med=new vector_t(m);

  sparse_a[nsparse-1]->left_mult2(cor, result);
  r=&result;
  for (long i=nsparse-2; i>=0; i--) {
    sparse_a[i]->left_mult2(*r, *med);
    s=med;
    med=r;
    r=s;
  }
  if (nsparse % 2 == 0) {
    for (index_t i=0; i<m; i++) result[i]=(*med)[i];
  }
  delete med;
}

template <class index_t, class real, class vector_t, class sparse_t>
vector_t * sc_sparse_array_t<index_t, real, vector_t, sparse_t>::left_mult2(vector_t *cor) {
  vector_t *result;
  result=new vector_t(m);
  left_mult2(*cor, *result);
  return result;
}

template <class index_t, class real, class vector_t, class sparse_t>
void sc_sparse_array_t<index_t, real, vector_t, sparse_t>::get_row2(index_t i, vector_t &row) {
  vector_t s1(m);
  for (index_t k=0; k<m; k++) s1[k]=0;
  s1[i]=1;
  left_mult2(s1, row);
}

template <class index_t, class real, class vector_t, class sparse_t>
vector_t *sc_sparse_array_t<index_t, real, vector_t, sparse_t>::get_row2(index_t i) {
  vector_t *row;
  row=new vector_t(m);
  get_row(i, *row);
  return row;
}


//multiply with a vector:
template <class index_t, class scalar, class vector_t>
void sc_full_t<index_t, scalar, vector_t>::vect_mult2(vector_t &cand, vector_t &result) {
  for (index_t i=0; i<m; i++) {
    result[i]=0;
    for (index_t j=0; j<n; j++) result[i]+=data[i][j]*cand[j];
  }
}

template <class index_t, class scalar, class vector_t>
vector_t * sc_full_t<index_t, scalar, vector_t>::vect_mult2(vector_t *cand) {
  vector_t *result;
  result=new vector_t(m);
  vect_mult2(*cand, *result);
  return result;
}

template <class index_t, class scalar, class vector_t>
void sc_full_t<index_t, scalar, vector_t>::left_mult2(vector_t &cor, vector_t &result) {
  for (index_t i=0; i<n; i++) result[i]=0;
  for (index_t i=0; i<m; i++) {
    for (index_t j=0; j<n; j++) {
      result[j]+=cor[i]*data[i][j];
    }
  }
}

template <class index_t, class scalar, class vector_t>
vector_t * sc_full_t<index_t, scalar, vector_t>::left_mult2(vector_t *cor) {
  vector_t *result;
  result=new vector_t(n);
  left_mult2(*cor, *result);
  return result;
}

template <class index_t, class scalar, class vector_t>
void sc_full_t<index_t, scalar, vector_t>::get_row2(index_t i, vector_t &row) {
  //pretty simple:
  for (index_t j=0; j<n; j++) row[j]=data[i][j];
}

template <class index_t, class scalar, class vector_t>
vector_t *sc_full_t<index_t, scalar, vector_t>::get_row2(index_t i) {
  vector_t *row;
  row=new vector_t(n);
  get_row(i, *row);
  return row;
}


}
}

