#ifndef SC_TYPE__H 
#define SC_TYPE__H

#include "sparse_array.h"

using namespace libpetey;
using namespace libsparse;

typedef double scalar_t;
typedef int32_t integer;

typedef sparse<integer, scalar_t> sparse_t;
typedef full_matrix<integer, scalar_t> full_t;
typedef sparse_array<integer, scalar_t> sparse_array_t; 

class sc_t {
  public:
    virtual ~sc_t()=0;
    int tflag;			//is it a temporary?
};

class sc_str_t: public sc_t {
  public:
    sc_str_t(char *str, int tf=0);
    virtual ~sc_str_t();
    char *s;

};

template <class scalar_t>
class sc_scal_t: public sc_t {
  public:
    sc_scal_t(scalar_t val, int tf=0);
    virtual ~sc_scal_t();
    scalar_t value;
};

template <class scalar_t>
class sc_vec_base: public sc_t {
  public:
    virtual ~sc_vec_base();
    virtual scalar_t operator [] (int i);
};

template <class scalar_t>
class sc_vec_t: public sc_vec_base<scalar_t> {
  protected:
    scalar_t *data;
    int n;
  public:
    sc_vec_t(int n1, int tf=1);
    sc_vec_t(char *filename, int tf=1);
    virtual ~sc_vec_t();

    scalar_t operator [] (int i);
};

template <class scalar_t>
class sc_view_t: public sc_vec_base<scalar_t> {
  protected:
    scalar_t **data;
    int n;
  public:
    sc_vec_t(sc_t *v1, sc_t *sub);
    virtual ~sc_vec_t();

    scalar_t operator [] (int i);
};


//basic arithmetic operators:
sc_t * sc_add(sc_t *v1, sc_t *v2);
sc_t * sc_minus(sc_t *v1, sc_t *v2);
int sc_minus(sc_t *v);
sc_t * sc_mult(sc_t *v1, sc_t *v2);
sc_t * sc_mod(sc_t *v1, sc_t *v2);
sc_t * sc_sub(sc_t *v1, sc_t *v2);
sc_t * sc_sub(sc_t *v1, sc_t *v2, sc_t *v3);
sc_t * sc_range(sc_t *v1, sc_t *v2);
sc_t * sc_cprod(sc_t *v1, sc_t *v2);
sc_t * sc_quot(sc_t *v1, sc_t *v2);
sc_t * sc_pow(sc_t *v1, sc_t *v2);
sc_t * sc_norm(sc_t *v);

//variable type as integer code:
int sc_type_of(sc_t *v);

#endif

