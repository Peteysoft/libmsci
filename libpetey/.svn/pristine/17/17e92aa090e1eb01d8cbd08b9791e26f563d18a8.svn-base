#include <ctype.h>

#include "linked.h"
#include "grammar_t.h"

parse_tree::parse_tree(expr_t *e, int v, char *l, int n, parse_tree **s) {
  expr=e;
  ver=v;
  loc=l;
  sub=s;
}

parse_tree::~parse_tree() {
  for (int i=0; expr->ns[ver]; i++) {
    delete sub[i];
  }
  delete [] sub;
}

char *parse_tree::value() {
  char *result;
  result=new char[len];
  for (int i=0; i<len; i++) result[i]=loc[i];
  return result;
}

void parse_tree::print(int depth) {
  char *name;
  for (int i=0; i<depth; i++) printf("  ");
  if (sub==NULL) {
    printf("%c\n", loc[0]);
  } else {
    char *val=value();
    name=expr->nameof();
    printf("%s %s\n", name, value);
    delete [] name;
    delete [] value;
    for (int i=0; i<expr->ns(ver); i++) {
      sub[i]->print(depth+1);
    }
  }
}


expr_t::expr_t() {}

expr_t::~expr_t() {}

primitive::primitive(char v1) {
  val=v1;
}

int primitive::nver() {
  return 1;
}

int primitive::ns(int v) {
  return 0;
}

char * primitive::nameof() {
  result *char=new char[2];
  result[0]=''';
  result[1]=val;
  return result;
}

parse_tree *primitive::parse(char *string, int ver) {
  parse_tree *result=NULL;
  if (string[0]==val && ver==0) {
    result=new parse_tree(this, 0, string, 1, NULL);
  }
  return result;
}

compound::compound(grammar_t *g, long i) {
  grammar=g;
  ntyp=0;
  id=i;
}

int compound::add(expr_t **neex, int n) {
  sub[ntyp]=neex;
  nsub[ntyp]=n;
  ntyp++;

  return ntyp;
}

int compound::nver() {
  return ntyp;
}

int compound::ns(int v) {
  return nsub[v];
}

char * compound::nameof() {
  return grammar->get(id);
}

parse_tree * compound::parse(char *string, int ver) {
  parse_tree **sub_tree;
  int v1;
  int i;
  int len;
  char *lnew;

  sub_tree=new parse_tree*[nsub[ver]];
  for (int j=0; j<nsub[ver]; j++) sub_tree[j]=NULL;

  for (i=0; i<nsub[ver]; i++) {
    if (sub_tree[i]==NULL) {
      v1=0;
    } else {
      v1=sub_tree[i]->ver+1;
      delete sub_tree[i];
      sub_tree[i]=NULL;
    }
    for (int j=v1; j<sub[ver][i]->nver(); j++) {
      if (i>0) {
        lnew=sub_tree[i-1]->loc+sub_tree[i-1]->len;
      } else {
        lnew=loc;
      }
      sub_tree[i]=sub[ver][i]->parse(lnew, j);
      if (sub_tree[i]!=NULL) break;
    }
    if (sub_tree[i]==NULL) {
      i--;
      if (i<0) break;
    }
  }

  if (i<nsub[ver]) {
    delete [] sub_tree;
    return NULL;
  }

  len=0;
  for (int j=0; j<nsub[ver]; j++) len+=sub_tree[j]->len;

  return new parse_tree(this, ver, loc, len, sub_tree);
}

grammar_t::grammar_t() {
}

int grammar_t::add(char *name1, char *def) {
  linked_list<int> start;
  linked_list<int> end;
  char oldc;
  int *ind1=NULL;
  int *ind2=NULL;
  int n1, n2;
  char *name2;
  expr_t **neex=NULL;
  long id, id1;
  int i;
  int err=0;

  //do nothing but find all the starts and ends of words (space-separated character strings):
  oldc=def[0];
  if (isalpha(oldc)) start.add(0);
  for (i=1; def[i]!='\0'; i++) {
    if (isblank(oldc) && isblank(def[i])!=1) {
      start.add(i);
    }
    if (isblank(def[i]) && isblank(oldc)!=1) {
      end.add(i);
    }
  }
  if (isblank(expr[i-1]!=1) end.add(i-1);

  ind1=start.make_array(n1);
  ind2=start.make_array(n2);

  assert(n1==n2);

  neex=new expr_t *[n1];

  for (i=0; i<n1; i++) {
    name2=def+ind1[i];
    name2[ind2[i]]='\0';
    if (name2[0]==''') {
      if (name2[1]=='\0') {
        fprintf(stderr, "grammar_t: syntax error, subexpr. %d\n", i);
        fprintf(stderr, "        --single quote must be followed by primitive\n");
        err=-1;
        goto finish;
      }
      if (name2[2]!='\0' || name2[2]!=''') {
        fprintf(stderr, "grammar_t: syntax error, subexpr. %d\n", i);
        fprintf(stderr, "        --primitives must be enclosed by single quotes or a quote and a space\n");
        err=-1;
        goto finish;
      }
      if (name2[2]==''') name[2]='\0';
      id=name.lookup(name2);
      if (id<0) {
        id=name.add(name2);
        exprlist[id]=new primitive(name2[1]);
      }
    } else if (isalpha(name2[0])!=1) {
      fprintf(stderr, "grammar_t: syntax error, subexpr. %d\n", i);
      fprintf(stderr, "        --expression names must begin with a letter\n");
      err=-1;
      goto finish;
    } else {
      for (int j=ind1[i]+1; j<ind2[i]; j++) {
        if (isalnum(def[j])!=1 || def[j]!='_') {
          fprintf(stderr, "grammar_t: syntax error, subexpr. %d\n", i);
          fprintf(stderr, "        --expression names must be composed of letters, number or underscores\n");
          err=-1;
          goto finish;
        }
      }
      id=name.lookup(name2);
      if (id<0) {
        fprintf(stderr, "grammar_t: symbol, %s, is undefined\n", name2);
        err=-2;
        goto finish;
      }
      id=name.add(name2);
    }
    neex[i]=exprlist[id];
  }

  id=name.lookup(name1);
  if (id<0) {
    name.add(name1);
    exprlist[id]=new compound(this, id);
  }
  exprlist[id]->add(neex, n1);

  finish:
    if (ind1!=NULL) delete [] ind1;
    if (ind2!=NULL) delete [] ind2;

  return err;
} 

int grammar_t::load(FILE *fs) {
  char **line;
  long nlines;
  int ptr1, ptr2;
  char *name;
  char *def;
  int nerr=0;

  line=read_ascii_all(fs, nlines);

  for (long i=0; i<nlines; i++) {
    for (ptr1=0; isalpha(line[i][ptr1])==0 && line[i][ptr1]!='\n'; ptr1++);
    if (line[i][ptr1]=='\n') continue;
    for (ptr2=ptr1; isblank(line[i][ptr2])==0 && line[i][ptr2]!='\n' && line[i][ptr2]!=':'; ptr2++);
    if (line[i][ptr2]=='\n') {
      fprintf(stderr, "syntax error line %d; skipped\n", i+1);
      nerr++;
      goto skip;
    }
    if (line[i][ptr2]==':') {
      name=line[i]+ptr1;
      name[ptr2]='\n';
    } else {
      for (ptr2++; isblank(line[i][ptr2]) && line[i][ptr2]!='\n'; ptr2++);
      if (line[i][ptr2]=='\n') {
        fprintf(stderr, "syntax error line %d; skipped\n", i+1);
        nerr++;
        goto skip;
      }
    }
    for (ptr1=ptr2; isalpha(line[i][ptr1])==0 && line[i][ptr1]!='\n'; ptr1++);
    if (line[i][ptr1]=='\n') {
      fprintf(stderr, "syntax error line %d; skipped\n", i+1);
      nerr++;
      goto skip;
    }
    for (ptr2=ptr1; isspace(line[i][ptr2])==0; ptr2++);
    def=line[i]+ptr1;
    def[ptr2]='\n';
    if (add(name, def)!=0) {
      fprintf(stderr, "syntax error line %d; skipped\n", i+1);
      nerr++;
    }
    skip:
      delete [] line[i];
  }

  return nerr;

}

parse_tree * grammar_t::parse(char *expr_name, char *string) {
  long id;
  int nver;
  parse_tree *result;

  id=name.lookup(string);
  if (id<0) return NULL;

  nver=exprlist[id]->nver();
  for (int i=0; i<nver; i++) {
    result=exprlist[id]->parse(string, i);
    if (result!=NULL) return;
  }

  return result;
}

parse_tree * grammar_t::parse(char *expr_name) {
  long id;
  int nver;
  parse_tree *result;

  id=name.entries(id)-1;
  if (id<0) return NULL;

  nver=exprlist[id]->nver();
  for (int i=0; i<nver; i++) {
    result=exprlist[id]->parse(string, i);
    if (result!=NULL) return;
  }

  return result;
}



