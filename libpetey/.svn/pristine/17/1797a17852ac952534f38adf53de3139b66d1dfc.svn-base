#ifndef MATRIX_BASE_H
#define MATRIX_BASE_H

#include <stdio.h>
#include <typeinfo>

//"null" matrix: i.e. pre-compute the dimensions for error-checking purposes

namespace libpetey {
  namespace libsparse {

    //forward declarations:
    template <class index_t, class scalar, class vector_t> class matrix_base;
    template <class index_t, class scalar, class vector_t> class sparse;
    template <class index_t, class scalar, class vector_t> class full_matrix;
    template <class index_t, class scalar, class vector_t, class sparse_t=sparse<index_t, scalar, vector_t> > class sparse_array;

    template <class index_t, class scalar, class vector_t>
    class matrix_base {
      private:
        index_t m;
        index_t n;

      public:
        matrix_base();
        matrix_base(index_t m1, index_t n1);
        matrix_base(matrix_base<index_t, scalar, vector_t> &other);
        matrix_base(matrix_base<index_t, scalar, vector_t> *other);
        virtual ~matrix_base();

        //access elements:
        virtual scalar operator ( ) (index_t i, index_t j);
        virtual long cel (scalar val, index_t i, index_t j);

        //access rows:
        virtual scalar *operator ( ) (index_t i);
        virtual vector_t *operator ( ) (index_t i);
        virtual void get_row(index_t i, scalar *row);
        virtual void get_row(index_t i, vector_t &row);

        //matrix multiplication:
        virtual matrix_base<index_t, scalar, vector_t> * mat_mult(matrix_base<index_t, scalar, vector_t> *cand);

        //matrix addition:
        virtual matrix_base<index_t, scalar, vector_t> * add(matrix_base<index_t, scalar, vector_t> *other);

        //vector multiplication:
        virtual scalar * vect_mult(scalar *cand);
        virtual scalar * left_mult(scalar *cor);

        virtual vector_t * vect_mult(vector_t *cand);
        virtual vector_t * left_mult(vector_t *cor);

        //should really be covered by the template versions...  oh well...
        virtual void vect_mult(scalar *cand, scalar *result);
        virtual void left_mult(scalar *cor, scalar *result);

        //the above are good for the sparse calculator, but not for solvers
        virtual void vect_mult(vector_t &cand, vector_t &result);
        virtual void left_mult(vector_t &cor, vector_t &result);

        //scalar multiplication:
        virtual void scal_mult(scalar cand);

        //take transpose: 
        virtual void transpose();

        //informational:
        virtual void dimensions(index_t &m, index_t &n) const;

        //norm:
        virtual scalar norm();

        //IO:
        virtual size_t read(FILE *fs);
        size_t read(FILE *fs, int mtype);
        virtual size_t write(FILE *fs);
        virtual void print(FILE *fs);
        virtual int scan(FILE *fs);

        //type conversion:
        virtual matrix_base<index_t, scalar, vector_t> & operator = (full_matrix<index_t, scalar, vector_t> &other);
        virtual matrix_base<index_t, scalar, vector_t> & operator = (sparse<index_t, scalar, vector_t> &other);
        virtual matrix_base<index_t, scalar, vector_t> & operator = (sparse_array<index_t, scalar, vector_t> &other);

        matrix_base<index_t, scalar, vector_t> & operator = (matrix_base<index_t, scalar, vector_t> &other);

        //need this so we can use the "matrix_base" class in the solver routines:
        virtual matrix_base<index_t, scalar, vector_t> * clone();

        //virtual operator sparse<index_t, scalar>& ()=0;
        //virtual operator sparse_array<index_t, scalar>& ()=0;
        //virtual operator full_matrix<index_t, scalar>& ()=0;

    };

    //to avoid creating a "clone" method--the designers of C++ really should
    //add polymorphic copying to the standard...
    template <class index_t, class scalar, class vector_t>
    matrix_base<index_t, scalar, vector_t> * copy_matrix(matrix_base<index_t, scalar, vector_t> *other);

  } //end namespace libsparse
} //end namespace libpetey

#endif

