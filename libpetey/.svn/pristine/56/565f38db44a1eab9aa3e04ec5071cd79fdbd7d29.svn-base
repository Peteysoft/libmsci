#include <string.h>

#include "sc_type.h"

//*********************  scalar type  *************************

sc_str_t::sc_str_t(char *str) {
  s=new char[strlen(str)+1];
  strcpy(s, str);
}

template <class scalar_t>
sc_scal_t<scalar_t>::sc_scal_t(scalar_t val) {
  value=val;
}

template <class scalar_t>
sc_t * sc_scal_t<scalar_t>::mult(sc_t *cand) {
  sc_t *result;
  int t=sc_type_of(cand);

  switch (t) {
    //multiply with another scalar:
    case (SC_SCALAR_T):
      result=new sc_scal_t<scalar_t>(((sc_scal_t *) cand)->value*value);
      break;
    //multiply with vector:
    case(SC_VECTOR_T):
    //multiply with matrix:
    case(SC_FULL_T):
    case(SC_SPARSE_T):
    case(SC_SPARSE_ARRAY_T):
    //multiply with list type:
    case(SC_LIST_T):
      result=cand->mult(this);
      break;
    default:
      result=NULL;
  }

  return result;
}

template <class scalar_t>
sc_t * sc_scal_t<scalar_t>::add(sc_t *cand) {
  sc_t *result;
  int t=sc_type_of(cand);

  switch (t) {
    //add to another scalar:
    case (SC_SCALAR_T):
      result=new sc_scal_t<scalar_t>(((sc_scal_t *) cand)->value+value);
      break;
    //add to a vector:
    case(SC_VECTOR_T):
    //add to a matrix:
    case(SC_FULL_T):
    case(SC_SPARSE_T):
    case(SC_SPARSE_ARRAY_T):
    //add to list type:
    case(SC_LIST_T):
      result=cand->add(this);
      break;
    default:
      result=NULL;
  }

  return result;
}

template <class scalar_t>
void sc_scal_t<scalar_t>::neg() {
  value=-value;
}

template <class scalar_t>
void sc_scal_t<scalar_t>::norm() {
  return new sc_scal_t<scalar_t>(fabs(value));
}

template <class scalar_t>
void sc_scal_t<scalar_t>::sub(sc_t *sub) {
  return NULL; 
}

//*********************  vector type  *************************

template <class scalar_t>
sc_vec_t<scalar_t>::sc_vec_t(scalar_t start, scalar_t finish) {
  n=(finish-start);
  data=new scalar_t[n];
  for (scalar_t i=0; i<n; i++) data[i]=start+i;
}

template <class scalar_t>
sc_vec_t<scalar_t>::sc_vec_t(sc_int_t n1) {
  n=n1;
  data=new scalar_t[n];
}

template <class scalar_t>
sc_vec_t<scalar_t>::sc_vec_t(char *filename) {
  FILE *fs=fopen(filename, "r");
  fseek(fs, 0, SEEK_END);
  n=ftell(fs)/sizeof(scalar_t);
  fseek(fs, 0, SEEK_SET);
  data=new scalar_t[n];
  fclose(fs);
}

template <class scalar_t>
sc_t * sc_vec_t<scalar_t>::mult(sc_t *cand) {
  sc_t *result;
  int t=sc_type_of(cand);

  switch (t) {
    //multiply with a scalar:
    case (SC_SCALAR_T):
      sc_vec_t<scalar_t> *r1;
      scalar_t value=((sc_scal_t *) cand)->value;
      r1=new sc_vec_t<scalar_t>(n);
      for (int i=0; i<n; i++) r1->data[i]=data[i]*value;
      result=r1;
      break;
    //multiply with vector:
    case(SC_VECTOR_T):
      sc_vec_t<scalar_t> *c1;
      scalar_t r1;
      c1=(sc_vec_t *) cand;
      if (c1->n != n) {
        fprintf(stderr, "Vector multiplication: vectors are different sizes (%d vs. %d)\n", n, c1->n);
        result=NULL;
        break;
      }
      r1=0;
      for (sc_int_t i=0; i<n; i++) r1+=data[i]*c1->data[i];
      result=new sc_scal_t<scalar_t>(r1);
      break;
    //multiply with matrix:
    case(SC_FULL_T):
    case(SC_SPARSE_T):
    case(SC_SPARSE_ARRAY_T):
      sc_int_t m1, n1;
      sc_vec_t<scalar_t> *r1;
      sc_mat_t<scalar_t> *c1=(sc_mat_t<scalar_t> *) cand;
      cand->mat->dimensions(m1, n1);
      if (m1 != n) {
        fprintf(stderr, "Vector-matrix product: vector dimension doesn't match matrix inner dimension (%d vs. %d)\n", n, m1);
        result=NULL;
        break;
      }
      r1=new sc_vec_t<scalar_t>(n1);
      c1->mat->left_mult(data, r1->data);
      result=r1;

    //multiply with list type:
    case(SC_LIST_T):
      break;
    default:
      result=NULL;
  }

  return result;
}

template <class scalar_t>
sc_t * sc_vec_t<scalar_t>::add(sc_t *cand) {
  sc_t *result;
  int t=sc_type_of(cand);

  switch (t) {
    //multiply with a scalar:
    case (SC_SCALAR_T):
      sc_vec_t<scalar_t> *r1;
      scalar_t value=((sc_scal_t *) cand)->value;
      r1=new sc_vec_t<scalar_t>(n);
      for (int i=0; i<n; i++) r1->data[i]=data[i]+value;
      result=r1;
      break;
    //multiply with vector:
    case(SC_VECTOR_T):
      sc_vec_t<scalar_t> *c1;
      c1=(sc_vec_t *) cand;
      if (c1->n != n) {
        fprintf(stderr, "Vector inner product: vectors are different sizes (%d vs. %d)\n", n, c1->n);
        result=NULL;
      } else {
        sc_vec_t *r1;
        r1=new sc_vec_t<scalar_t>(n);
        for (sc_int_t i=0; i<n; i++) r1->data[i]=data[i]+c1->data[i];
        result=r1;
      }
      break;
    //multiply with matrix:
    case(SC_FULL_T):
    case(SC_SPARSE_T):
    case(SC_SPARSE_ARRAY_T):
    case(SC_LIST_T):
      cand->add(this);
      break;
    default:
      result=NULL;
  }

  return result;
}

template <class scalar_t>
void sc_vec_t<scalar_t>::neg() {
  for (sc_int_t i; i<n; i++) data[i]=-data[i];
}

template <class scalar_t>
sc_t * sc_vec_t<scalar_t>::operator [] (sc_t *sub) {
  sc_t *result;
  sc_int_t ind;
  int t=sc_type_of(cand);

  switch (t) {
    //subscript with scalar:
    case (SC_SCALAR_T):
      ind=sub->value;
      if (ind<0 || ind>=sub->n) {
        fprintf(stderr, "Scalar subscript (%d) of vector out-of-range\n", ind);
        result=NULL;
        break;
      }
      result=new sc_scal_t<scalar_t>(data[ind]);
      break;
    //subscript with vector:
    case(SC_VECTOR_T):
      sc_vec_t<scalar_t> *r1=new sc_vec_t<scalar_t>(sub->n);
      for (sc_int_t i=0; i<sub->n; i++) {
        ind=sub->data[i];
        if (ind<0 || ind>=sub->n) {
          fprintf(stderr, "Vector subscript (%d) of vector out-of-range\n", ind);
          result=NULL;
          delete [] r1;
          break;
        }
        if (r1==NULL) break;
        r1->data[i]=data[ind];
      }
    //type mismatch:
    case(SC_FULL_T):
    case(SC_SPARSE_T):
    case(SC_SPARSE_ARRAY_T):
    case(SC_LIST_T):
    default:
      fprintf(stderr, "Type mismatch: only scalar or vector subscripts allowed\n");
      result=NULL;
  }

  return result;
}


//*********************  matrix type  *************************

template <class scalar_t>
sc_t * sc_mat_t<scalar_t>::sc_mat_t() {
  mat=NULL;
}

template <class scalar_t>
sc_t * sc_mat_t<scalar_t>::mult(sc_t *cand) {
  sc_mat_t *result;
  int t=sc_type_of(cand);

  switch (t) {
    //multiply with a scalar:
    case (SC_SCALAR_T):
      sc_mat_t<scalar_t> *r1=new sc_mat_t<scalar_t>();
      r1->mat=copy_matrix(this);
      r1->mat->scal_mult(((sc_scal_t<scalar_t> *) cand)->value);
      result=r1;
      break;
    //multiply with a vector:
    case(SC_VECTOR_T):
      sc_vect_t<scalar_t> * c1=(sc_vect_t<scalar_t> *) cand;
      sc_int_t m, n;
      mat->dimensions(m, n);
      if (c1->n != n) {
        fprintf(stderr, "Vector multiplication: inner dimensions must match (%d vs. %d)\n", n, c1->n);
        result=NULL;
      } else {
        r1->data=mat->vect_mult(c1->data);
        r1->n=m;
      }
      break;
    //multiply with matrix:
    case(SC_FULL_T):
    case(SC_SPARSE_T):
    case(SC_SPARSE_ARRAY_T):
      sc_mat_t<scalar_t> *c1=(sc_mat_t<scalar_t> *) cand;
      sc_mat_t<scalar_t> *r1=new sc_mat_t<scalar_t>();
      r1->mat=mat->mult(c1->mat);
      break;
    //multiply with list type:
    case(SC_LIST_T):
      //need to fill this space...
      break;
    default:
      result=NULL;
  }

  return result;
}

template <class scalar_t>
sc_t * sc_mat_t<scalar_t>::add(sc_t *cand) {
  sc_mat_t *result;
  sc_int_t m, n;

  //gather some information:
  mat->dimensions(m, n);
  int t=sc_type_of(cand);

  //result is always a matrix:
  result=new sc_mat_t();

  switch (t) {
    //add to a scalar:
    case (SC_SCALAR_T):
      full_matrix<sc_int_t, scalar_t> *c1=new full_matrix<sc_int_t, scalar_t>(m, n);
      c1->ones();
      c1->scal_mult(((sc_scal_t<scalar_t> *) cand)->value);
      result->mat=mat->add(c1);
      break;
    //add to a vector:
    case(SC_VECTOR_T):
      sc_vect_t<scalar_t> * c1=(sc_vect_t<scalar_t> *) cand;
      sparse<sc_int_t, scalar_t> *c2=new sparse<sc_int_t, scalar_t>(m, n);
      c2->identity();
      for (sc_int_t i=0; i<m && i<n && i<c1->n; i++) {
        c2->cel(c1->data[i], i, i);
      }
      result->data=mat->add(c2);
      break;
    //add to matrix:
    case(SC_FULL_T):
    case(SC_SPARSE_T):
    case(SC_SPARSE_ARRAY_T):
      sc_mat_t<scalar_t> *c1=(sc_mat_t<scalar_t> *) cand;
      result->mat=mat->add(c1->mat);
      break;
    //multiply with list type:
    case(SC_LIST_T):
      //need to fill this space...
      break;
    default:
      result=NULL;
  }

  return result;
}

//*********************  list type  *************************


