#include "error_codes.h"

#include "full_matrix.h"
#include "full_util.h"
#include "sparse_array.h"

namespace libpetey {
namespace libsparse {

//initialization routines:
template <class index_t, class scalar, class vector_t>
full_matrix<index_t, scalar, vector_t>::full_matrix() {
  m=0;
  n=0;
  data=NULL;
}

template <class index_t, class scalar, class vector_t>
full_matrix<index_t, scalar, vector_t>::full_matrix(matrix_base<index_t, scalar, vector_t> *other) {
  if (typeid(*other) == typeid(sparse<index_t, scalar, vector_t>)) {
    sparse<index_t, scalar, index_t> * dum;
    //printf("Assigning sparse matrix to full matrix\n");
    dum=(sparse<index_t, scalar, index_t> *) other;
    dum->dimensions(m, n);
    data=(scalar **) (*dum);
    //print_matrix(stdout, data, m, n);
  } else if (typeid(*other) == typeid(sparse_array<index_t, scalar, vector_t>)) {
    sparse_array<index_t, scalar, vector_t> * dum;
    printf("Converting sparse array to full:");
    other->dimensions(m, n);
    dum=(sparse_array<index_t, scalar, vector_t>*) other;
    data=(scalar **) (*dum);
  } else if (typeid(*other) == typeid(full_matrix<index_t, scalar, vector_t>)) {
    full_matrix<index_t, scalar, vector_t> * dum;
    dum=(full_matrix<index_t, scalar, vector_t> *) other;
    m=dum->m;
    n=dum->n;
    data=libpetey::copy_matrix<scalar, index_t>(dum->data, m, n);
  } else {
    fprintf(stderr, "Failed to initialize full matrix from base class\n");
  }

};

/*
template <class index_t, class scalar, class vector_t>
full_matrix<index_t, scalar, vector_t> & full_matrix<index_t, scalar, vector_t>::operator = (matrix_base<index_t, scalar, vector_t> &other) {
  if (typeid(other) == typeid(sparse<index_t, scalar, vector_t>)) {
    return *this=*((sparse<index_t, scalar, index_t> *) &other);
  } else if (typeid(other) == typeid(sparse_array<index_t, scalar, vector_t>)) {
    return *this=*(sparse_array<index_t, scalar, vector_t> *) &other;
  } else if (typeid(other) == typeid(full_matrix<index_t, scalar, vector_t>)) {
    return *this=*(full_matrix<index_t, scalar, vector_t> *) &other;
  }

};
*/

//initialization routines:
template <class index_t, class scalar, class vector_t>
full_matrix<index_t, scalar, vector_t>::full_matrix(index_t min, index_t nin) {
  m=min;
  n=nin;
  data=zero_matrix<scalar, index_t>(m, n);
}

template <class index_t, class scalar, class vector_t>
void full_matrix<index_t, scalar, vector_t>::ones() {
  for (index_t i=0; i<m; i++) {
    for (index_t j=0; j<n; j++) {
      data[i][j]=1;
    }
  }
}

template <class index_t, class scalar, class vector_t>
void full_matrix<index_t, scalar, vector_t>::identity() {
  zero_matrix<scalar, index_t>(data, m, n);
  for (index_t i=0; i<m && i<n; i++) data[i][i]=1;
}

template <class index_t, class scalar, class vector_t>
full_matrix<index_t, scalar, vector_t>::full_matrix(scalar *dat, index_t min, index_t nin) {
  m=min;
  n=nin;
  data=allocate_matrix<scalar, index_t>(m, n);
  for (index_t i=0; i<n*m && i<m; i++) data[0][i]=dat[i];
}

template <class index_t, class scalar, class vector_t>
full_matrix<index_t, scalar, vector_t>::full_matrix(scalar **dat, index_t min, index_t nin) {
  m=min;
  n=nin;
  data=libpetey::copy_matrix<scalar, index_t>(dat, m, n);
}

//destructor:
template <class index_t, class scalar, class vector_t>
full_matrix<index_t, scalar, vector_t>::~full_matrix() {
  delete_matrix(data);
}

template <class index_t, class scalar, class vector_t>
scalar full_matrix<index_t, scalar, vector_t>::operator() (index_t i, index_t j) {
  return data[i][j];
}

template <class index_t, class scalar, class vector_t>
void full_matrix<index_t, scalar, vector_t>::get_row(index_t i, scalar *row) {
  //pretty simple:
  for (index_t j=0; j<n; j++) row[j]=data[i][j];
}

template <class index_t, class scalar, class vector_t>
scalar *full_matrix<index_t, scalar, vector_t>::operator() (index_t i) {
  scalar *row;
  row=new scalar[n];
  get_row(i, row);
  return row;
}

template <class index_t, class scalar, class vector_t>
long full_matrix<index_t, scalar, vector_t>::cel (scalar val, index_t i, index_t j) {
  data[i][j]=val;
  return i*m+j;
}

//multiply with another full matrix:
template <class index_t, class scalar, class vector_t>
matrix_base<index_t, scalar, vector_t> * full_matrix<index_t, scalar, vector_t>::mat_mult(matrix_base<index_t, scalar, vector_t> *cand) {
  matrix_base<index_t, scalar, vector_t> *result;
  index_t m1, n1;
  cand->dimensions(m1, n1);
  if (n!=m1) {
    fprintf(stderr, "Matrix inner dimensions must match ([%dx%d]*[%dx%d]\n", 
		    m, n, m1, n1);
    result=NULL;
  } else if (typeid(*cand) == typeid(full_matrix<index_t, scalar, vector_t>)) {
    result=new full_matrix<index_t, scalar, vector_t>(m, n1);
    //ugly way of doing it:
    matrix_mult<scalar, index_t>(data, 
		((full_matrix<index_t, scalar, vector_t> *) cand)->data, 
		((full_matrix<index_t, scalar, vector_t> *) result)->data, 
		m, n, n1);
  } else if (typeid(*cand) == typeid(sparse<index_t, scalar, vector_t>)) {
    result=new full_matrix<index_t, scalar, vector_t>(m, n1);
    ((sparse<index_t, scalar, index_t> *) cand)->left_m_mult(this->data, 
		((full_matrix<index_t, scalar, vector_t> *) result)->data, m);
  } else if (typeid(*cand) == typeid(sparse_array<index_t, scalar, vector_t>)) {
    if (m != n) {
      full_matrix<index_t, scalar, vector_t> cand2;
      cand2=*(full_matrix<index_t, scalar, vector_t> *) cand;
      result=mat_mult(&cand2);
    } else {
      result=new full_matrix<index_t, scalar, vector_t>(m, n1);
      ((sparse_array<index_t, scalar, vector_t> *) cand)->left_m_mult(this->data, 
			((full_matrix<index_t, scalar, vector_t> *) result)->data);
    }
  } else if (typeid(*cand) == typeid(matrix_base<index_t, scalar, vector_t>)) {
    result=new matrix_base<index_t, scalar, vector_t>(m, n1);
    //do nothing
  } else {
    fprintf(stderr, "full_matrix::mat_mult - error, matrix type not recognized\n");
    result=NULL;
  } 
  return result;
} 

//matrix addition:
template <class index_t, class scalar, class vector_t>
matrix_base<index_t, scalar, vector_t> * full_matrix<index_t, scalar, vector_t>::add(matrix_base<index_t, scalar, vector_t> *b) {
  matrix_base<index_t, scalar, vector_t> *result;
  index_t m1, n1;
  b->dimensions(m1, n1);

  if (n!=n1 || m1!=m) {
    fprintf(stderr, "Matrix dimensions must match ([%dx%d]+[%dx%d]\n", 
		    m, n, m1, n1);
    result=NULL;
  } else if (typeid(*b) == typeid(full_matrix<index_t, scalar, vector_t>)) {
    result=new full_matrix<index_t, scalar, vector_t>();
    ((full_matrix<index_t, scalar, vector_t> *) result)->data =
		libpetey::copy_matrix<scalar, index_t>(data, m, n);
    matrix_add<scalar, index_t>(
		((full_matrix<index_t, scalar, vector_t> *) result)->data, 
		((full_matrix<index_t, scalar, vector_t> *) b)->data, m, n);
    ((full_matrix<index_t, scalar, vector_t> *) result)->m=m;
    ((full_matrix<index_t, scalar, vector_t> *) result)->n=n;
  } else if (typeid(*b) == typeid(sparse<index_t, scalar, index_t>)) {
    result=b->add(this);
  } else if (typeid(*b) == typeid(sparse_array<index_t, scalar, vector_t>)) {
    result=b->add(this);
  } else if (typeid(*b) == typeid(matrix_base<index_t, scalar, vector_t>)) {
    result=new matrix_base<index_t, scalar, vector_t>(m, n1);
    //do nothing
  } else {
    fprintf(stderr, "full_matrix::add - error, matrix type not recognized\n");
    result=NULL;
  } 
  return result;
}

//multiply with a vector:
template <class index_t, class scalar, class vector_t>
scalar * full_matrix<index_t, scalar, vector_t>::vect_mult(scalar *cand) {
  return vector_mult<scalar, index_t>(data, cand, m, n);
} 

template <class index_t, class scalar, class vector_t>
scalar * full_matrix<index_t, scalar, vector_t>::left_mult(scalar *cor) {
  return left_vec_mult<scalar, index_t>(cor, data, m, n);
} 

template <class index_t, class scalar, class vector_t>
vector_t * full_matrix<index_t, scalar, vector_t>::vect_mult(vector_t *cand) {
  vector_t *result;
  result=new vector_t(m);
  vect_mult(*cand, *result);
  return result;
} 

template <class index_t, class scalar, class vector_t>
vector_t * full_matrix<index_t, scalar, vector_t>::left_mult(vector_t *cor) {
  vector_t *result;
  result=new vector_t(n);
  left_mult(*cor, *result);
  return result;
} 

//multiply with a vector:
template <class index_t, class scalar, class vector_t>
void full_matrix<index_t, scalar, vector_t>::vect_mult(vector_t &cand, vector_t &result) {
  for (index_t i=0; i<m; i++) {
    result[i]=0;
    for (index_t j=0; j<n; j++) result[i]+=data[i][j]*cand[j];
  }
} 

template <class index_t, class scalar, class vector_t>
void full_matrix<index_t, scalar, vector_t>::vect_mult(scalar *cand, scalar *result) {
  vector_mult<scalar, index_t>(data, cand, result, m, n);
}

template <class index_t, class scalar, class vector_t>
void full_matrix<index_t, scalar, vector_t>::left_mult(vector_t &cor, vector_t &result) {
  for (index_t i=0; i<n; i++) result[i]=0;
  for (index_t i=0; i<m; i++) {
    for (index_t j=0; j<n; j++) {
      result[j]+=cor[i]*data[i][j];
    }
  }
} 

template <class index_t, class scalar, class vector_t>
void full_matrix<index_t, scalar, vector_t>::left_mult(scalar *cor, scalar *result) {
  left_vec_mult<scalar, index_t>(cor, data, result, m, n);
}

//copy constructor:
template <class index_t, class scalar, class vector_t>
full_matrix<index_t, scalar, vector_t>::full_matrix(full_matrix<index_t, scalar, vector_t> &other) {
  m=other.m;
  n=other.n;
  data=libpetey::copy_matrix<scalar, index_t>(other.data, m, n);
}

//type conversion:
template <class index_t, class scalar, class vector_t>
matrix_base<index_t, scalar, vector_t> & full_matrix<index_t, scalar, vector_t>::operator = 
		(full_matrix<index_t, scalar, vector_t> &other) {
  if (data != NULL) delete_matrix(data);
  m=other.m;
  n=other.n;
  data=libpetey::copy_matrix<scalar, index_t>(other.data, m, n);
  return *this;
}

//copy constructor
template <class index_t, class scalar, class vector_t>
full_matrix<index_t, scalar, vector_t>::full_matrix(sparse<index_t, scalar, vector_t> &other) {
  other.dimensions(m, n);
  data=(scalar **) other;
}

//type conversion:
template <class index_t, class scalar, class vector_t>
matrix_base<index_t, scalar, vector_t> & full_matrix<index_t, scalar, vector_t>::operator = 
		(sparse<index_t, scalar, index_t> &other) {
  if (data != NULL) delete_matrix(data);
  other.dimensions(m, n);
  data=(scalar **) other;
  return *this;
}

template <class index_t, class scalar, class vector_t>
full_matrix<index_t, scalar, vector_t>::full_matrix(sparse_array<index_t, scalar, vector_t> &other) {
  other.dimensions(m, n);
  data=(scalar **) other;
}

template <class index_t, class scalar, class vector_t>
matrix_base<index_t, scalar, vector_t> & full_matrix<index_t, scalar, vector_t>::operator = 
		(sparse_array<index_t, scalar, vector_t> &other) {
  if (data != NULL) delete_matrix(data);
  other.dimensions(m, n);
  printf("Converting sparse array to full:");
  data=(scalar **) other;
  return *this;
}

template <class index_t, class scalar, class vector_t>
void full_matrix<index_t, scalar, vector_t>::dimensions(index_t &mout, index_t &nout) const {
  mout=m;
  nout=n;
}

//should probably return a new matrix:
template <class index_t, class scalar, class vector_t>
void full_matrix<index_t, scalar, vector_t>::transpose() {
  scalar **nm;
  scalar sw1;

  if (m==n) {
    matrix_transpose<scalar, index_t>(data, m);
  } else {
    nm=matrix_transpose<scalar, index_t>(data, m, n);
    delete_matrix(data);
    data=nm;
    sw1=m;
    m=n;
    n=sw1;
  }

}

//should probably return a new matrix:
template <class index_t, class scalar, class vector_t>
void full_matrix<index_t, scalar, vector_t>::scal_mult(scalar cand) {
  for (long i=0; i<m*n; i++) data[0][i]=cand*data[0][i];
}
	
template <class index_t, class scalar, class vector_t>
int full_matrix<index_t, scalar, vector_t>::scan(FILE *fs) {
  data=scan_matrix<scalar, index_t>(fs, m, n);
  //should do a bit better error handling here...
  if (data!=NULL) return 0;
  return FILE_READ_ERROR;
}

template <class index_t, class scalar, class vector_t>
size_t full_matrix<index_t, scalar, vector_t>::read(FILE *fs) {
  if (data!=NULL) delete_matrix(data);
  data=read_matrix<scalar, index_t>(fs, m, n);
  if (data==NULL) return 0;
  return m*n+2;
}

template <class index_t, class scalar, class vector_t>
size_t full_matrix<index_t, scalar, vector_t>::write(FILE *fs) {
  return write_matrix(fs, data, m, n);
}

template <class index_t, class scalar, class vector_t>
void full_matrix<index_t, scalar, vector_t>::print(FILE *fs) {
  print_matrix(fs, data, m, n);
}

template <class index_t, class scalar, class vector_t>
matrix_base<index_t, scalar, vector_t> * full_matrix<index_t, scalar, vector_t>::clone() {
  full_matrix<index_t, scalar, vector_t> *result;
  result=new full_matrix<index_t, scalar, vector_t>(this);
  return result;

}

template <class index_t, class scalar, class vector_t>
scalar full_matrix<index_t, scalar, vector_t>::norm() {
  return matrix_norm(data, m, n);
}

/*
template <class index_t, class data_t>
full_matrix<index_t, data_t>::operator sparse<index_t, data_t, vector_t>& () {
  sparse<index_t, data_t, vector_t> *result;
  result=new sparse<index_t, data_t, vector_t>(*this);
  return *result;
}

template <class index_t, class data_t>
full_matrix<index_t, data_t>::operator sparse_array<index_t, data_t, vector_t>& () {
  sparse_array<index_t, data_t, vector_t> *result;
  result=new sparse_array<index_t, data_t, vector_t>(*this);
  return *result;
}

template <class index_t, class data_t>
full_matrix<index_t, data_t>::operator full_matrix<index_t, data_t, vector_t>& () {
  full_matrix<index_t, data_t, vector_t> *result;
  result=new full_matrix(*this);
  return *result;
}
*/

//template class full_matrix<int16_t, float>;
template class full_matrix<ind_t, float, vector_t>;
template class full_matrix<ind_t, double, vector_t>;

} //end namespace libsparse
} //end namespace libpetey

