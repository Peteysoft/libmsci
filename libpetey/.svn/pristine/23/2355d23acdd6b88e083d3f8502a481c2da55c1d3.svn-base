#include "sc_glob.h"
#include "sc_op.h"

sc_t *sc_neg(int narg, sc_t **v) {
  int t;
  sc_t *result=NULL;

  if (narg != 1) return NULL;

  int t=sc_type_of(v[0]);

  if (t==SC_SCALAR_T) {
    sc_scal_t *v0=(sc_scal_t *) v[0];
    if (v0->tflag) {
      v0->value=-v0=>value;
      result=v0;
    } else {
      sc_scal_t *r1=new sc_scal_t(1);
      r1->value=-v0->value;
      result=r1;
    }
  } else if (t==SC_VECTOR_T) {
    sc_vec_t *v0=(sc_vec_t *) v[0];
    if (v0->tflag) {
      for (int i=0; i<v0->n; i++) v0->data[i]=-v0->data[i];
      result=v0;
    } else {
      sc_vec_t *r1=new sc_vec_t(1);
      r1->n=v0->n;
      r1->data=new scalar_t[r1->n];
      for (int i=0; i<v0->n; i++) r1->data[i]=-v0->data[i];
      result=r1;
    }
  } else if (t==SC_SPARSE_T || t==SC_FULL_T || t==SC_SPARSE_ARRAY_T) {
    sc_mat_t *v0=(sc_mat_t *) v[0];
    if (v0->tflag) {
      v0->mat->scal_mult(-1);
      result=v0;
    } else {
      sc_mat_t *r1=new sc_mat_t(1);
      r1->mat=copy_matrix(v1->mat);
      result=r1;
    }
  } else {
    fprintf(stderr, "Type mismatch\n");
  }
  return result;
}

sc_t *sc_prod(int narg, sc_t **v) {
  sc_t *result=NULL;
  int t1, t2;		//types of each argument
  int d1f=1, d2f=1;	//delete argument at end?

  if (narg != 2) return NULL;

  t1=sc_type_of(v[0]);
  t2=sc_type_of(v[1]);

  //both scalars:
  if (t1==SC_SCALAR_T && t2==SC_SCALAR_T) {
    sc_scal_t *v1=(sc_scal_t *) v[0];
    sc_scal_t *v2=(sc_scal_t *) v[1];
    result=new sc_scal_t(v1->value*v2->value, 1);

  //one scalar, one vector:
  } else if ((t1==SC_SCALAR_T && t2==SC_VECTOR_T) || (t2==SC_SCALAR_T && t1==SC_VECTOR_T)) {
    sc_scal_t *v1;
    sc_vec_t *v2;
    sc_vec_t *r1;
    if (t1==SC_SCALAR_T && t2==SC_VECTOR_T) {
      v1=(sc_scal_t *) v[0];
      v2=(sc_vec_t *) v[1];
    } else if (t2==SC_SCALAR_T && t1==SC_VECTOR_T) {
      v1=(sc_scal_t *) v[1];
      v2=(sc_vec_t *) v[0];
    }
    r1=new sc_vec_t(1);
    r1->data=new scalar_t[v2->n];
    r1->n=v2->n;
    for (int i=0; i<r1->n; i++) r1->data[i]=v2->data[i]*v1->value;
    result=r1;

  //both are vectors:
  } else if (t1==SC_VECTOR_T && t2==SC_VECTOR_T) {
    sc_vec_t *v1=(sc_vec_t *) v[0];
    sc_vec_t *v2=(sc_vec_t *) v[1];
    scalar_t val=0;
    if (v1->n != v2->n) {
      fprintf(stderr, "Type mismatch: vector dimensions do not agree\n");
      return NULL;
    }
    for (int i=0; i<v1->n; i++) val+=v1->data[i]*v2->data[i];
    result=new sc_scal_t(val, 1);

  //scalar and matrix:
  } else if ((t1==SC_SCALAR_T &&
		(t2==SC_FULL_T || t2==SC_SPARSE_T || t2==SC_SPARSE_ARRAY_T)) ||
		((t1==SC_FULL_T || t1==SC_SPARSE_T || t1==SC_SPARSE_ARRAY_T) ||
		(t2==SC_SCALAR_T))) {
    sc_mat_t *v1;
    sc_scal_t *v2;
    if (t1==SC_SCALAR_T &&
		(t2==SC_FULL_T || t2==SC_SPARSE_T || t2==SC_SPARSE_ARRAY_T)) {
      v2=(sc_scal_t *) v[0];
      v1=(sc_mat_t *) v[1];
      d2f=0;
    } else if ((t1==SC_FULL_T || t1==SC_SPARSE_T || t1==SC_SPARSE_ARRAY_T) ||
		(t2==SC_SCALAR_T)) {
      v1=(sc_mat_t *) v[0];
      v2=(sc_scal_t *) v[1];
      d1f=0;
    }
    v1->mat->scal_mult(v2->value);
    result=v1;

  //vector and matrix:
  } else if (t1==SC_VECTOR_T &&
		(t2==SC_FULL_T || t2==SC_SPARSE_T || t2==SC_SPARSE_ARRAY_T)) {
    integer m, n;
    sc_vec_t *v1=(sc_vec_t *) v[0];
    sc_mat_t *v2=(sc_mat_t *) v[1];
    sc_vec_t *r1;
    v2->mat->dimensions(m, n);
    if (m!=v1->n) {
      fprintf(stderr, "Vector size and matrix inner dimension must match\n");
      return NULL;
    }
    r1=new sc_vec_t(1);
    r1->data=v2->mat->left_mult(v1->data);
    r1->n=n;
    result=r1;

  //matrix and vector:
  } else if ((t1==SC_FULL_T || t1==SC_SPARSE_T || t1==SC_SPARSE_ARRAY_T) ||
		(t2==SC_VECTOR_T)) {
    integer m, n;
    sc_mat_t *v1=(sc_mat_t *) v[0];
    sc_vec_t *v2=(sc_vec_t *) v[1];
    sc_vec_t *r1;
    v1->mat->dimensions(m, n);
    if (n!=v2->n) {
      fprintf(stderr, "Matrix inner dimension and vector size must match\n");
      return NULL;
    }
    result=new sc_vec_t(1);
    r1=new sc_vec_t(1);
    r1->data=v1->mat->vect_mult(v2->data);
    r1->n=m;
    result=r1;

  //both are matrices:
  } else if ((t2==SC_FULL_T || t2==SC_SPARSE_T || t2==SC_SPARSE_ARRAY_T) &&
		(t1==SC_FULL_T || t1==SC_SPARSE_T || t1==SC_SPARSE_ARRAY_T)) {
    sc_mat_t *v1=(sc_mat_t *) v[0];
    sc_mat_t *v2=(sc_mat_t *) v[1];
    sc_mat_t *r1=new sc_mat_t(1);
    r1->mat=v1->mat->mat_mult(v2->mat);
    result=r1;

  } else {
    fprintf(stderr, "Type mismatch\n");
  }

  if (d1f && v[0]->tflag) delete v[0];
  if (d2f && v[1]->tflag) delete v[1];

  return result;
}

sc_t *sc_add(int narg, sc_t **v) {
  sc_t *result=NULL;
  int t1, t2;		//types of each argument

  if (narg != 2) return NULL;

  t1=sc_type_of(v[0]);
  t2=sc_type_of(v[1]);

  //both scalars:
  if (t1==SC_SCALAR_T && t2==SC_SCALAR_T) {
    sc_scal_t *v1=(sc_scal_t *) v[0];
    sc_scal_t *v2=(sc_scal_t *) v[1];
    result=new sc_scal_t(v1->value+v2->value, 1);

  //one scalar, one vector:
  } else if ((t1==SC_SCALAR_T && t2==SC_VECTOR_T) || (t2==SC_SCALAR_T && t1==SC_VECTOR_T)) {
    sc_scal_t *v1;
    sc_vec_t *v2;
    sc_vec_t *r1;
    if (t1==SC_SCALAR_T && t2==SC_VECTOR_T) {
      v1=(sc_scal_t *) v[0];
      v2=(sc_vec_t *) v[1];
    } else if (t2==SC_SCALAR_T && t1==SC_VECTOR_T) {
      v1=(sc_scal_t *) v[1];
      v2=(sc_vec_t *) v[0];
    }
    r1=new sc_vec_t(1);
    r1->data=new scalar_t[v2->n];
    r1->n=v2->n;
    for (int i=0; i<r1->n; i++) r1->data[i]=v2->data[i]+v1->value;
    result=r1;

  //both are vectors:
  } else if (t1==SC_VECTOR_T && t2==SC_VECTOR_T) {
    sc_vec_t *v1=(sc_vec_t *) v[0];
    sc_vec_t *v2=(sc_vec_t *) v[1];
    sc_vec_t *r1;
    if (v1->n != v2->n) {
      fprintf(stderr, "Type mismatch: vector dimensions do not agree\n");
      return NULL;
    }
    r1=new sc_vec_t(1);
    r1->n=v1->n;
    r1->data=new scalar_t[r1->n];
    for (int i=0; i<v1->n; i++) r1->data[i]=v1->data[i]+v2->data[i];
    result=r1;

  //scalar and matrix:
  } else if ((t1==SC_SCALAR_T &&
		(t2==SC_FULL_T || t2==SC_SPARSE_T || t2==SC_SPARSE_ARRAY_T)) ||
		((t1==SC_FULL_T || t1==SC_SPARSE_T || t1==SC_SPARSE_ARRAY_T) ||
		(t2==SC_SCALAR_T))) {
    sc_mat_t *v1;
    sc_scal_t *v2;
    sc_mat_t *r1;
    full_t *c;
    integer m, n;
    if (t1==SC_SCALAR_T &&
		(t2==SC_FULL_T || t2==SC_SPARSE_T || t2==SC_SPARSE_ARRAY_T)) {
      v1=(sc_mat_t *) v[1];
      v2=(sc_scal_t *) v[0];
    } else if ((t1==SC_FULL_T || t1==SC_SPARSE_T || t1==SC_SPARSE_ARRAY_T) ||
		(t2==SC_SCALAR_T)) {
      v1=(sc_mat_t *) v[0];
      v2=(sc_scal_t *) v[1];
    }
    v1->mat->dimensions(m, n);
    c=new full_t(m, n);
    c->ones();
    c->scal_mult(v2->value);
    r1=new sc_mat_t(1);
    r1->mat=v1->mat->add(c);
    delete c;
    result=r1;

  //vector and matrix:
  } else if ((t1==SC_VECTOR_T &&
		(t2==SC_FULL_T || t2==SC_SPARSE_T || t2==SC_SPARSE_ARRAY_T)) ||
		((t1==SC_FULL_T || t1==SC_SPARSE_T || t1==SC_SPARSE_ARRAY_T) ||
		(t2==SC_VECTOR_T))) {
    integer m, n, n1;
    sc_mat_t *v1;
    sc_vec_t *v2;
    sc_mat_t *r1;
    sparse_t *diag;
    if (t1==SC_VECTOR_T &&
		(t2==SC_FULL_T || t2==SC_SPARSE_T || t2==SC_SPARSE_ARRAY_T)) {
      v2=(sc_vec_t *) v[0];
      v1=(sc_mat_t *) v[1];
    } else if ((t1==SC_FULL_T || t1==SC_SPARSE_T || t1==SC_SPARSE_ARRAY_T) ||
		(t2==SC_VECTOR_T)) {
      v1=(sc_mat_t *) v[0];
      v2=(sc_vec_t *) v[1];
    }
    v1->mat->dimensions(m, n);
    if (m<n) n1=m; else n1=n;
    if (n1!=v2->n) {
      fprintf(stderr, "Smallest matrix dimension and vector size must match\n");
      return NULL;
    }
    diag=new sparse_t(m, n);
    diag->identity();
    for (integer i=0; i<n1; i++) diag->cel(v2->data[i], i, i);
    r1=new sc_mat_t(1);
    r1->mat=v1->mat->add(diag);
    delete diag;
    result=r1;

  //both are matrices:
  } else if ((t2==SC_FULL_T || t2==SC_SPARSE_T || t2==SC_SPARSE_ARRAY_T) &&
		(t1==SC_FULL_T || t1==SC_SPARSE_T || t1==SC_SPARSE_ARRAY_T)) {
    sc_mat_t *v1=(sc_mat_t *) v[0];
    sc_mat_t *v2=(sc_mat_t *) v[1];
    sc_mat_t *r1;
    r1=new sc_mat_t(1);
    r1->mat=v1->mat->add(v2->mat);
    result=r1;

  //result undefined:
  } else {
    fprintf(stderr, "Type mismatch\n");
  }

  //currently, all variables in ram are temporaries:
  if (v[0]->tflag) delete v[0];
  if (v[1]->tflag) delete v[1];

  return result;
}

sc_t *sc_minus(int narg, sc_t **v) {
  sc_t *result=NULL;
  sc_t *v2[2];

  if (narg != 2) return NULL;

  v2[0]=v[0];
  v2[1]=sc_neg(1, v+1);
  return sc_add(2, v2);
}

  
